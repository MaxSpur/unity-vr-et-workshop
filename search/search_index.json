{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to the Unity VR and Eye Tracking Workshop! Hello and thank you for participating in this workshop! Here you'll learn about the basics of the Unity game engine : How to create and run a first 3D environment How to interact with 3D objects and how to animate them, and How to script them with more complex behaviors. More specifically for a use-case in psychological/perceptual research, it will also teach you about: Setting up a VR environment with eye tracking (specifically the HTC Vive Pro Eye), Recording and outputting eye tracking data from players or participants, and How to interpret these results. In order to condense the workshop and save time, we have already prepared the computers you'll be working on with all necessary software and editing environments. If you want to repeat the process on your own equipment or in your lab, the page on Installation and Setup will lead you to our recommended setup, but for now you can directly start with the first part , which will teach you about creating your first unity project with a simple 3D object. You can navigate the page with the buttons below, or using the links in the directory on the left (or behind the menu icon). Feel free to ask you tutors about any issues you might be having at any point, they are here to help you. We hope you'll enjoy the journey!","title":"Welcome"},{"location":"#welcome-to-the-unity-vr-and-eye-tracking-workshop","text":"Hello and thank you for participating in this workshop! Here you'll learn about the basics of the Unity game engine : How to create and run a first 3D environment How to interact with 3D objects and how to animate them, and How to script them with more complex behaviors. More specifically for a use-case in psychological/perceptual research, it will also teach you about: Setting up a VR environment with eye tracking (specifically the HTC Vive Pro Eye), Recording and outputting eye tracking data from players or participants, and How to interpret these results. In order to condense the workshop and save time, we have already prepared the computers you'll be working on with all necessary software and editing environments. If you want to repeat the process on your own equipment or in your lab, the page on Installation and Setup will lead you to our recommended setup, but for now you can directly start with the first part , which will teach you about creating your first unity project with a simple 3D object. You can navigate the page with the buttons below, or using the links in the directory on the left (or behind the menu icon). Feel free to ask you tutors about any issues you might be having at any point, they are here to help you. We hope you'll enjoy the journey!","title":"Welcome to the Unity VR and Eye Tracking Workshop!"},{"location":"1-first-project/","text":"First Unity Project \u2014 getting to know the Editors Create a first project using the Unity Hub If not already running on your computer, start the Unity Hub (see the icon above). Depending on previous use there may be already projects listed in its window \u2014 if so, disregard them for now and just click the New project button. You will be presented with a dialog to configure the project. Usually it's already all set up correctly, but to make sure just verify the following points: Editor Version should be the latest one from the list (2021.3.11f1 in our case), The 3D template should be selected, Don't forget to give your first project a name and choose a location (the default works here). Pushing the Create project button will open the Unity Editor and tell it create a new project with the above parameters. This may take some time\u2026 Setting up the Editor Once this process is complete, you will see a the Unity Editor in its default configuration, showing a blank scene. You can leave this as is, or drag the tab handles and section dividers around to create a more comfortable working environment. One particularly important change would be to permanently reveal the Console window by dragging the Project window it's being obscured by to a new location. Below is our suggested arrangement with new placements of the Hierarchy, Project, and Console windows. The biggest part should show you the Scene View, where you can freely navigate using common 3D software controls, like zooming in and out with the mouse wheel, rotating by holding the right mouse button, and translating your position by holding the middle mouse button. See the official Unity manual on more information on this. Scene, Hierarchy, and Camera Views + Inspector The Scene View shows you the contents of your currently open Scene \u2014 a kind of super Object that holds all other objects. A full overview of all objects and their relationships is shown in the Hierarchy window \u2014 as you can see, it currently only contains our only Scene ( SampleScene ), which holds a simple Directional Light for illuminating the world and the Main Camera that lets a player see it. Let's select that camera by clicking on it in the Hierarchy or on its Gizmo (camera icon) in the Scene view: It is now highlighted in both Scene and Hierarchy views, as shown by a highlight and the appearance of arrows pointing in the cardinal directions around the object. In addition, a view from this camera now shows up in the Scene view as a floating window: this is what a player of this game will see if we run it. The same view is visible in a full window by selecting the Game tab in the Scene window. Another thing that happens when we select a Game Object like this camera in the editor is the appearance of this object's Inspector in its previously empty window to the top right. This window allows us to view and change every single aspect of any Game Object, which may differ by their type. One Component all possible objects, be they cameras, lights, or dinosaur models share is their Transform: a grid that contains the coordinates of their position, rotation vector, and its scale. Transforms and Hierarchies In the case of the camera and light and any other objects directly under the SampleScene Scene object, these coordinates are equivalent to their \"world\" coordinates. For any object that sits below another in the Hierarchy, these coordinates are basically offset by those of their Parent. See Unity's documentation on the Hierarchy and Transforms for more details. Let's set the camera's Position to the origin and rotate it to point in the blue arrow's (the Z-axis) direction by editing its Transform Component accordingly: set Position X=0, Y=0, Z=0 and Rotation X=0, Y=90, Z=0 . Creating a first object Let's bring a cube into the scene. While you can go to the main menu under GameObject and select what you want to create, a more precise way is to right-click on an empty part of the Hierarchy and selecting 3D Object \u2192 Cube . This will create a basic cube GameObject inside our Scene, with a default Transform. If we had right-clicked on any existing object in the scene instead of on an empty space, we would have created a child object that would be tied to its parent, and this is not what we want in this case. If you double-click on the new Cube object in the hierarchy, the scene view will fully zoom into it, showing that it basically swallowed our camera. If you select our camera object again, its view (or the Game View) won't show the cube \u2014 the way most 3D engines work, objects are transparent from the inside. Let's move the box to a position where the camera can see it, and also try making it smaller by setting its transform component to Position X=2, Y=0, Z=0 and Scale X=0.2, Y=0.2, Z=0.2 . Selecting our camera again, we can now see a small box appearing at the center of its view. If the cube is now gone from our scene view, just zoom out a bit, or double-click it again in the hierarchy. You can keep playing around with the cube's Transform component to move it around and scale it, or also use the handles in the scene view: dragging one of the three arrows or the squares between them will also change the transform accordingly. More on Positioning There are many more ways to change the transform with the mouse. You can switch transform modes by pressing W , E , R , or by selecting the different icons in the little floating window in the scene view to move, rotate, scale an object, respectively. See the Unity Documentation for more details on this. A first animation All we did so far is not much different than using any basic 3D creation software. Where a game engine like Unity differs, is its ability of freely scripting the objects we place in scenes, using programming languages. Creating a first script file Let's try this out by making a script that will constantly rotate our cube. The easiest way to do this is by clicking the Add Component button at the bottom of the cube's Inspector and just starting to type the name of the script we want to create in the search field, in this case let's name it Rotating . It will automatically understand that we want to create a new script, so select that option and then confirm by pressing Create and Add . After a bit of waiting, the Unity editor will have created a new file inside its Assets folder, which you can see inside the Project View by clicking on the new Script component in the cube's Inspector. The newly created script \u2014 C#! Double-clicking the Script field in the cube's Script component, or on the script's icon in the Project view will bring up a text editor (Visual Studio Code in this case, if everything is set up properly) with the script file, named Rotating.cs already opened. With the editor you can now make changes to the script! The Unity editor will take all changes into account every time you save your changes in the text editor and switch focus back to the Unity editor. Every script you create using the above way will be a C# , or C Sharp script, as can be seen by its \".cs\" ending. Unity will always create a new script file with a basic structure pre-written, looking like this: Rotating.cs using System.Collections ; using System.Collections.Generic ; using UnityEngine ; public class Rotating : MonoBehaviour { // Start is called before the first frame update void Start () { } // Update is called once per frame void Update () { } } The first three lines (beginning with using ) tell Unity which Software Libraries to load before executing any of the code, which allow it to access e.g. Unity's built-in functionalities and data types, or anything else you might want to include. The next block, surrounded by the curly brackets { } of public class Rotating : MonoBehaviour encompass all functionality of this script, in the simplest case. It tells Unity that this block defines a MonoBehavior object , which is the kind of script object that one can attach to GameObjects in the Unity's hierarchy. Within the curly brackets there are already the outlines of two standard functions that many scripts use: void Start() and void Update() . As already explained by the comments above them (any lines that start with // are disregarded by Unity and are only there for the programmer to read), the code within the curly brackets of Start() will be executed only once, at the very start of each run of the \"game,\" while the contents of Update() will be called every time the screen refreshes. The empty round brackets ( ) following the names of these functions mean that they don't accept any input variables, and void before their names signifies that they don't output anything, either. Running the script As all this code is still basically empty, running it won't change anything \u2014 you can try this by pressing the Play button at the top middle of the Unity editor, which will compile any scripts you might have changed, switch to the Game view (the view of our main camera), and execute all scripts that are attached to GameObjects within the hierarchy. As expected, the game view shows the main camera's perspective on a static cube. You can still access the cube's inspector by clicking on it in the hierarchy, where you can make changes to its transform by e.g. clicking and dragging the desired coordinates. Exiting the Play mode by again pressing the play button will reset any changes that we made in the hierarchy and inspector back to how they were before, and will again show the scene view by default. Editing the script \u2014 constant rotation around a fixed axis Let's edit the Rotating.cs script so that it actually does something when the game runs. What we want to happen is to change something about the cube's transform every time the screen refreshes. This can be accomplished by adding one line of code inside the given void Update() function, so that it looks like this: Rotating.cs void Update () { transform . Rotate ( Vector3 . up , 30.0f * Time . deltaTime ); } What this does it to call the Rotate() function of the GameObject's transform component with the parameters Vector3.up for the rotation axis, and 30.0f * Time.deltaTime for the rotation angle \u2014 for every frame that the game runs. If you type this yourself in the code editor instead of copying and pasting, you might see code completion kicking in, which offers suggestions and explanations of each of these fields. Vector3.up is short for a three-dimensional vector that points straight up, and Time.deltaTime is the time that has passed since the last frame before the current one is called. 30.0f is the simply a convention of writing f loating point numbers, as opposed to integers. If we save this script file, go back to Unity and hit the Play button, we will once again see the camera's view in the Game view, with the cube steadily rotating around its vertical axis, at 30 degrees per second. Making the script interactive For now, this rotation is fixed \u2014 while you can still manually change the transform in the game view as above, the cube keeps rotating. You can try move it around or rotate it around the X or Z axes to see its automatic rotation change direction relative to the world, but staying constant relative to the cube. To make the automatic rotation more interactive, we can edit our script to include variables, which need to be placed outside the Update() method, but still within the curly brackets of the Rotating class. Let's change these parts of the script to look like this: Rotating.cs public class Rotating : MonoBehaviour { [Tooltip(\"Rotation angle per second\")] public float speed = 30.0f ; [Tooltip(\"Vector of the rotation axis\")] public Vector3 axis = Vector3 . up ; // Update is called once per frame void Update () { transform . Rotate ( axis , speed * Time . deltaTime ); } } Variables are introduced by stating their type first, then their name, like float speed \u2014 a floating point number that we reference by the name \"speed.\" If we want to make a variable accessible to scripts outside the its current scope (the Rotating MonoBehavior in this case), we need to prefix them with public . Like this we can also directly see their current value in the Unity's inspector, as parameters of the cube's script component. It is often necessary, and usually a good practice to initialize new variables with a certain default value, which is assigned with the equals sign = and a following value. Here we can give them exactly what we had previously put in to the parameters for the Rotate() function: 30.0f for speed , and Vector3.up for axis . Finally, we need to replace the fixed values in the transform.Rotate() call with our new variables: transform.Rotate(axis, speed * Time.deltaTime); does that. Optionally, we can make these parameters that are now exposed in the inspector even more legible by adding the tooltips in the format shown above, before the public definitions of the variables. Try it out: save the script, go back to the Unity editor, hit Play. You see the same rotation going on, but can now directly edit the rotation's parameters the same way you can interact with the cube's transform! Online/offline editing of values Like before, changes in the inspector that happen while the game is running will be reverted to their default when you stop, but will stay if you make them while it's not running. If you change the axis or rotation speed while the game is off, the new values will override what you have as initial values in the code. If you go back to the code and put in new initial values and save, then these will overwrite anything currently set in the inspector. Warning Always make sure that the game is not playing while you make changes you want to keep , especially when adding/removing objects and components! Combining animations A second script to move it To practice more with animating an object, let's create a new script for the cube as we did before, by adding a new script component and naming it Moving . As before, we can keep the pre-build structure and just add to it. With the new script, we want to move the cube between two specified points in space, at a certain speed. Let's add these variables to the Moving MonoBehavior, similar to how we did it above: Moving.cs public class Moving : MonoBehaviour { [Tooltip(\"Units per second\")] public float speed = 1.0f ; [Tooltip(\"Starting position in 3D space\")] public Vector3 startPoint = new Vector3 ( 2 , 0 , - 1 ); [Tooltip(\"End position in 3D space\")] public Vector3 endPoint = new Vector3 ( 2 , 0 , 1 ); // Update is called once per frame void Update () { } } The main difference is how we're defining new Vectors now for startPoint and endPoing : we're initializing them with their coordinates. Save this code, and make sure that the this new component appears in the cube's inspector with the correct values we gave it in the code. If not, you can change the speed and points to their values right there. Interpolation To move between these two points, we need to interpolate between them as time passes. For that, let's add another variable that will keep track of where in between the two points the cube should be. This time we keep it private \u2014 it will not be accessible by outside scripts, as want to only change it internally. We can still display its value in the inspector though by adding a line above its declaration to make it a \"serialized field:\" Moving.cs public class Moving : MonoBehaviour { [Tooltip(\"Units per second\")] public float speed = 1.0f ; [Tooltip(\"Starting position in 3D space\")] public Vector3 startPoint = new Vector3 ( 2 , 0 , - 1 ); [Tooltip(\"End position in 3D space\")] public Vector3 endPoint = new Vector3 ( 2 , 0 , 1 ); [SerializeField] private float interpolator = - 1.0f ; // Update is called once per frame void Update () { } We set it to -1 initially, and want to constantly increase it. This is accomplished by the += operation in the Update() loop: we take its current value and add to it the time since the last frame multiplied by the speed, as before. When it reaches or exceeds 1 we will reset it back to -1 , so that it will loop forever between these values. This is done by testing it inside an if() statement: if the contents of its round brackets () are true (is the interpolator greater than or equal to one?), then the contents within its curly brackets {} are executed: {set the interpolator back to -1}. Moving.cs public class Moving : MonoBehaviour { [Tooltip(\"Units per second\")] public float speed = 1.0f ; [Tooltip(\"Starting position in 3D space\")] public Vector3 startPoint = new Vector3 ( 2 , 0 , - 1 ); [Tooltip(\"End position in 3D space\")] public Vector3 endPoint = new Vector3 ( 2 , 0 , 1 ); [SerializeField] private float interpolator = - 1.0f ; // Update is called once per frame void Update () { interpolator += speed * Time . deltaTime ; if ( interpolator >= 1 ) { interpolator = - 1 ; } } To translate this into a movement for the cube, we need this interpolator to affect the position part of its transform. For that we can use the Lerp() function of Vector3 : it takes a starting and and ending point, and a value between zero and one that lets it calculate a new point in between. Since our interpolator goes between -1 and 1, we need to alter it slightly before we give to this Lerp() function, which we can do directly inside its parameter field: Moving.cs public class Moving : MonoBehaviour { [Tooltip(\"Units per second\")] public float speed = 1.0f ; [Tooltip(\"Starting position in 3D space\")] public Vector3 startPoint = new Vector3 ( 2 , 0 , - 1 ); [Tooltip(\"End position in 3D space\")] public Vector3 endPoint = new Vector3 ( 2 , 0 , 1 ); [SerializeField] private float interpolator = - 1.0f ; // Update is called once per frame void Update () { interpolator += speed * Time . deltaTime ; if ( interpolator >= 1 ) { interpolator = - 1 ; } transform . position = Vector3 . Lerp ( startPoint , endPoint , interpolator < 0 ? - interpolator : interpolator ); } ?: or Ternary Conditional Operator The structure with the form x < y ? a : b is a handy shortcut : we test if x is smaller than y (or any other comparison we need here), and return a if true and b if false. Here give the Lerp() function the negative of interpolator if it's smaller than zero, thus making it actually positive again. If interpolator already is positive, it is directly given to Lerp() . Enter this code, save it, and run the game: Interplay You can now see the cube moving from side to side, while still spinning from its Rotating script! As before, you can play around with the parameters to change the speed (of both the rotation and translation) and with the starting and end points. You can also disable any of the two scripts at any time during the game by clicking their checkmark, which will freeze their execution and stop them influencing the cube. Connecting objects Instead of this mad spinning, let's make this cube rotate face the camera at all times instead. Looking at First, deactivate the Rotating component while outside the game mode, so that this change sticks. Then, let's add two lines to our Moving script: Moving.cs public class Moving : MonoBehaviour { [Tooltip(\"Units per second\")] public float speed = 1.0f ; [Tooltip(\"Starting position in 3D space\")] public Vector3 startPoint = new Vector3 ( 2 , 0 , - 1 ); [Tooltip(\"End position in 3D space\")] public Vector3 endPoint = new Vector3 ( 2 , 0 , 1 ); [Tooltip(\"Object to face\")] public Transform targetObject ; [SerializeField] private float interpolator = - 1.0f ; // Update is called once per frame void Update () { interpolator += speed * Time . deltaTime ; if ( interpolator >= 1 ) { interpolator = - 1 ; } transform . position = Vector3 . Lerp ( startPoint , endPoint , interpolator < 0 ? - interpolator : interpolator ); transform . LookAt ( targetObject ); } We now gave it a new variable ( targetObject ), this time a Transform . This lets us reference any other GameObject's transform, and therefore e.g. its position. The new last line within the Update() loop uses the LookAt() method from the transform class, which will orient the current GameObject's transform to\u2026 look at, or face in the direction of another transform that we give it. Referencing objects Note how we did not initialize this variable in the code; we will instead assign it from the inspector. One way to do it is to click the target icon that now sits in the new variable field in the cube's inspector and select the Main Camera object from the list that appears, or simply drag the Main Camera from the hierarchy into the field: We can see the cube now moving from side to side and always facing the camera if we play it, but to display this new behavior more clearly we can arrange our Unity editor to show the scene and game views at the same time to have an external view. Changing the starting and end points, or the position of the camera will not hinder from lookAt always adjusting the cube's position correctly: If everything works and you've understood every part, you should have now have the basics of Unity down, congratulations! Now onwards to some actual VR \u2014 expect less handholding from now on ;-) Ask for help Remember, if anything is unclear or doesn't work: don't hesitate to ask the tutors.","title":"1 \u2022\u00a0First Unity Project"},{"location":"1-first-project/#first-unity-project-getting-to-know-the-editors","text":"","title":"First Unity Project \u2014 getting to know the Editors"},{"location":"1-first-project/#create-a-first-project-using-the-unity-hub","text":"If not already running on your computer, start the Unity Hub (see the icon above). Depending on previous use there may be already projects listed in its window \u2014 if so, disregard them for now and just click the New project button. You will be presented with a dialog to configure the project. Usually it's already all set up correctly, but to make sure just verify the following points: Editor Version should be the latest one from the list (2021.3.11f1 in our case), The 3D template should be selected, Don't forget to give your first project a name and choose a location (the default works here). Pushing the Create project button will open the Unity Editor and tell it create a new project with the above parameters. This may take some time\u2026","title":"Create a first project using the Unity Hub"},{"location":"1-first-project/#setting-up-the-editor","text":"Once this process is complete, you will see a the Unity Editor in its default configuration, showing a blank scene. You can leave this as is, or drag the tab handles and section dividers around to create a more comfortable working environment. One particularly important change would be to permanently reveal the Console window by dragging the Project window it's being obscured by to a new location. Below is our suggested arrangement with new placements of the Hierarchy, Project, and Console windows. The biggest part should show you the Scene View, where you can freely navigate using common 3D software controls, like zooming in and out with the mouse wheel, rotating by holding the right mouse button, and translating your position by holding the middle mouse button. See the official Unity manual on more information on this.","title":"Setting up the Editor"},{"location":"1-first-project/#scene-hierarchy-and-camera-views-inspector","text":"The Scene View shows you the contents of your currently open Scene \u2014 a kind of super Object that holds all other objects. A full overview of all objects and their relationships is shown in the Hierarchy window \u2014 as you can see, it currently only contains our only Scene ( SampleScene ), which holds a simple Directional Light for illuminating the world and the Main Camera that lets a player see it. Let's select that camera by clicking on it in the Hierarchy or on its Gizmo (camera icon) in the Scene view: It is now highlighted in both Scene and Hierarchy views, as shown by a highlight and the appearance of arrows pointing in the cardinal directions around the object. In addition, a view from this camera now shows up in the Scene view as a floating window: this is what a player of this game will see if we run it. The same view is visible in a full window by selecting the Game tab in the Scene window. Another thing that happens when we select a Game Object like this camera in the editor is the appearance of this object's Inspector in its previously empty window to the top right. This window allows us to view and change every single aspect of any Game Object, which may differ by their type. One Component all possible objects, be they cameras, lights, or dinosaur models share is their Transform: a grid that contains the coordinates of their position, rotation vector, and its scale. Transforms and Hierarchies In the case of the camera and light and any other objects directly under the SampleScene Scene object, these coordinates are equivalent to their \"world\" coordinates. For any object that sits below another in the Hierarchy, these coordinates are basically offset by those of their Parent. See Unity's documentation on the Hierarchy and Transforms for more details. Let's set the camera's Position to the origin and rotate it to point in the blue arrow's (the Z-axis) direction by editing its Transform Component accordingly: set Position X=0, Y=0, Z=0 and Rotation X=0, Y=90, Z=0 .","title":"Scene, Hierarchy, and Camera Views + Inspector"},{"location":"1-first-project/#creating-a-first-object","text":"Let's bring a cube into the scene. While you can go to the main menu under GameObject and select what you want to create, a more precise way is to right-click on an empty part of the Hierarchy and selecting 3D Object \u2192 Cube . This will create a basic cube GameObject inside our Scene, with a default Transform. If we had right-clicked on any existing object in the scene instead of on an empty space, we would have created a child object that would be tied to its parent, and this is not what we want in this case. If you double-click on the new Cube object in the hierarchy, the scene view will fully zoom into it, showing that it basically swallowed our camera. If you select our camera object again, its view (or the Game View) won't show the cube \u2014 the way most 3D engines work, objects are transparent from the inside. Let's move the box to a position where the camera can see it, and also try making it smaller by setting its transform component to Position X=2, Y=0, Z=0 and Scale X=0.2, Y=0.2, Z=0.2 . Selecting our camera again, we can now see a small box appearing at the center of its view. If the cube is now gone from our scene view, just zoom out a bit, or double-click it again in the hierarchy. You can keep playing around with the cube's Transform component to move it around and scale it, or also use the handles in the scene view: dragging one of the three arrows or the squares between them will also change the transform accordingly. More on Positioning There are many more ways to change the transform with the mouse. You can switch transform modes by pressing W , E , R , or by selecting the different icons in the little floating window in the scene view to move, rotate, scale an object, respectively. See the Unity Documentation for more details on this.","title":"Creating a first object"},{"location":"1-first-project/#a-first-animation","text":"All we did so far is not much different than using any basic 3D creation software. Where a game engine like Unity differs, is its ability of freely scripting the objects we place in scenes, using programming languages.","title":"A first animation"},{"location":"1-first-project/#creating-a-first-script-file","text":"Let's try this out by making a script that will constantly rotate our cube. The easiest way to do this is by clicking the Add Component button at the bottom of the cube's Inspector and just starting to type the name of the script we want to create in the search field, in this case let's name it Rotating . It will automatically understand that we want to create a new script, so select that option and then confirm by pressing Create and Add . After a bit of waiting, the Unity editor will have created a new file inside its Assets folder, which you can see inside the Project View by clicking on the new Script component in the cube's Inspector.","title":"Creating a first script file"},{"location":"1-first-project/#the-newly-created-script-c","text":"Double-clicking the Script field in the cube's Script component, or on the script's icon in the Project view will bring up a text editor (Visual Studio Code in this case, if everything is set up properly) with the script file, named Rotating.cs already opened. With the editor you can now make changes to the script! The Unity editor will take all changes into account every time you save your changes in the text editor and switch focus back to the Unity editor. Every script you create using the above way will be a C# , or C Sharp script, as can be seen by its \".cs\" ending. Unity will always create a new script file with a basic structure pre-written, looking like this: Rotating.cs using System.Collections ; using System.Collections.Generic ; using UnityEngine ; public class Rotating : MonoBehaviour { // Start is called before the first frame update void Start () { } // Update is called once per frame void Update () { } } The first three lines (beginning with using ) tell Unity which Software Libraries to load before executing any of the code, which allow it to access e.g. Unity's built-in functionalities and data types, or anything else you might want to include. The next block, surrounded by the curly brackets { } of public class Rotating : MonoBehaviour encompass all functionality of this script, in the simplest case. It tells Unity that this block defines a MonoBehavior object , which is the kind of script object that one can attach to GameObjects in the Unity's hierarchy. Within the curly brackets there are already the outlines of two standard functions that many scripts use: void Start() and void Update() . As already explained by the comments above them (any lines that start with // are disregarded by Unity and are only there for the programmer to read), the code within the curly brackets of Start() will be executed only once, at the very start of each run of the \"game,\" while the contents of Update() will be called every time the screen refreshes. The empty round brackets ( ) following the names of these functions mean that they don't accept any input variables, and void before their names signifies that they don't output anything, either.","title":"The newly created script \u2014\u00a0C#!"},{"location":"1-first-project/#running-the-script","text":"As all this code is still basically empty, running it won't change anything \u2014 you can try this by pressing the Play button at the top middle of the Unity editor, which will compile any scripts you might have changed, switch to the Game view (the view of our main camera), and execute all scripts that are attached to GameObjects within the hierarchy. As expected, the game view shows the main camera's perspective on a static cube. You can still access the cube's inspector by clicking on it in the hierarchy, where you can make changes to its transform by e.g. clicking and dragging the desired coordinates. Exiting the Play mode by again pressing the play button will reset any changes that we made in the hierarchy and inspector back to how they were before, and will again show the scene view by default.","title":"Running the script"},{"location":"1-first-project/#editing-the-script-constant-rotation-around-a-fixed-axis","text":"Let's edit the Rotating.cs script so that it actually does something when the game runs. What we want to happen is to change something about the cube's transform every time the screen refreshes. This can be accomplished by adding one line of code inside the given void Update() function, so that it looks like this: Rotating.cs void Update () { transform . Rotate ( Vector3 . up , 30.0f * Time . deltaTime ); } What this does it to call the Rotate() function of the GameObject's transform component with the parameters Vector3.up for the rotation axis, and 30.0f * Time.deltaTime for the rotation angle \u2014 for every frame that the game runs. If you type this yourself in the code editor instead of copying and pasting, you might see code completion kicking in, which offers suggestions and explanations of each of these fields. Vector3.up is short for a three-dimensional vector that points straight up, and Time.deltaTime is the time that has passed since the last frame before the current one is called. 30.0f is the simply a convention of writing f loating point numbers, as opposed to integers. If we save this script file, go back to Unity and hit the Play button, we will once again see the camera's view in the Game view, with the cube steadily rotating around its vertical axis, at 30 degrees per second.","title":"Editing the script \u2014 constant rotation around a fixed axis"},{"location":"1-first-project/#making-the-script-interactive","text":"For now, this rotation is fixed \u2014 while you can still manually change the transform in the game view as above, the cube keeps rotating. You can try move it around or rotate it around the X or Z axes to see its automatic rotation change direction relative to the world, but staying constant relative to the cube. To make the automatic rotation more interactive, we can edit our script to include variables, which need to be placed outside the Update() method, but still within the curly brackets of the Rotating class. Let's change these parts of the script to look like this: Rotating.cs public class Rotating : MonoBehaviour { [Tooltip(\"Rotation angle per second\")] public float speed = 30.0f ; [Tooltip(\"Vector of the rotation axis\")] public Vector3 axis = Vector3 . up ; // Update is called once per frame void Update () { transform . Rotate ( axis , speed * Time . deltaTime ); } } Variables are introduced by stating their type first, then their name, like float speed \u2014 a floating point number that we reference by the name \"speed.\" If we want to make a variable accessible to scripts outside the its current scope (the Rotating MonoBehavior in this case), we need to prefix them with public . Like this we can also directly see their current value in the Unity's inspector, as parameters of the cube's script component. It is often necessary, and usually a good practice to initialize new variables with a certain default value, which is assigned with the equals sign = and a following value. Here we can give them exactly what we had previously put in to the parameters for the Rotate() function: 30.0f for speed , and Vector3.up for axis . Finally, we need to replace the fixed values in the transform.Rotate() call with our new variables: transform.Rotate(axis, speed * Time.deltaTime); does that. Optionally, we can make these parameters that are now exposed in the inspector even more legible by adding the tooltips in the format shown above, before the public definitions of the variables. Try it out: save the script, go back to the Unity editor, hit Play. You see the same rotation going on, but can now directly edit the rotation's parameters the same way you can interact with the cube's transform!","title":"Making the script interactive"},{"location":"1-first-project/#onlineoffline-editing-of-values","text":"Like before, changes in the inspector that happen while the game is running will be reverted to their default when you stop, but will stay if you make them while it's not running. If you change the axis or rotation speed while the game is off, the new values will override what you have as initial values in the code. If you go back to the code and put in new initial values and save, then these will overwrite anything currently set in the inspector. Warning Always make sure that the game is not playing while you make changes you want to keep , especially when adding/removing objects and components!","title":"Online/offline editing of values"},{"location":"1-first-project/#combining-animations","text":"","title":"Combining animations"},{"location":"1-first-project/#a-second-script-to-move-it","text":"To practice more with animating an object, let's create a new script for the cube as we did before, by adding a new script component and naming it Moving . As before, we can keep the pre-build structure and just add to it. With the new script, we want to move the cube between two specified points in space, at a certain speed. Let's add these variables to the Moving MonoBehavior, similar to how we did it above: Moving.cs public class Moving : MonoBehaviour { [Tooltip(\"Units per second\")] public float speed = 1.0f ; [Tooltip(\"Starting position in 3D space\")] public Vector3 startPoint = new Vector3 ( 2 , 0 , - 1 ); [Tooltip(\"End position in 3D space\")] public Vector3 endPoint = new Vector3 ( 2 , 0 , 1 ); // Update is called once per frame void Update () { } } The main difference is how we're defining new Vectors now for startPoint and endPoing : we're initializing them with their coordinates. Save this code, and make sure that the this new component appears in the cube's inspector with the correct values we gave it in the code. If not, you can change the speed and points to their values right there.","title":"A second script to move it"},{"location":"1-first-project/#interpolation","text":"To move between these two points, we need to interpolate between them as time passes. For that, let's add another variable that will keep track of where in between the two points the cube should be. This time we keep it private \u2014 it will not be accessible by outside scripts, as want to only change it internally. We can still display its value in the inspector though by adding a line above its declaration to make it a \"serialized field:\" Moving.cs public class Moving : MonoBehaviour { [Tooltip(\"Units per second\")] public float speed = 1.0f ; [Tooltip(\"Starting position in 3D space\")] public Vector3 startPoint = new Vector3 ( 2 , 0 , - 1 ); [Tooltip(\"End position in 3D space\")] public Vector3 endPoint = new Vector3 ( 2 , 0 , 1 ); [SerializeField] private float interpolator = - 1.0f ; // Update is called once per frame void Update () { } We set it to -1 initially, and want to constantly increase it. This is accomplished by the += operation in the Update() loop: we take its current value and add to it the time since the last frame multiplied by the speed, as before. When it reaches or exceeds 1 we will reset it back to -1 , so that it will loop forever between these values. This is done by testing it inside an if() statement: if the contents of its round brackets () are true (is the interpolator greater than or equal to one?), then the contents within its curly brackets {} are executed: {set the interpolator back to -1}. Moving.cs public class Moving : MonoBehaviour { [Tooltip(\"Units per second\")] public float speed = 1.0f ; [Tooltip(\"Starting position in 3D space\")] public Vector3 startPoint = new Vector3 ( 2 , 0 , - 1 ); [Tooltip(\"End position in 3D space\")] public Vector3 endPoint = new Vector3 ( 2 , 0 , 1 ); [SerializeField] private float interpolator = - 1.0f ; // Update is called once per frame void Update () { interpolator += speed * Time . deltaTime ; if ( interpolator >= 1 ) { interpolator = - 1 ; } } To translate this into a movement for the cube, we need this interpolator to affect the position part of its transform. For that we can use the Lerp() function of Vector3 : it takes a starting and and ending point, and a value between zero and one that lets it calculate a new point in between. Since our interpolator goes between -1 and 1, we need to alter it slightly before we give to this Lerp() function, which we can do directly inside its parameter field: Moving.cs public class Moving : MonoBehaviour { [Tooltip(\"Units per second\")] public float speed = 1.0f ; [Tooltip(\"Starting position in 3D space\")] public Vector3 startPoint = new Vector3 ( 2 , 0 , - 1 ); [Tooltip(\"End position in 3D space\")] public Vector3 endPoint = new Vector3 ( 2 , 0 , 1 ); [SerializeField] private float interpolator = - 1.0f ; // Update is called once per frame void Update () { interpolator += speed * Time . deltaTime ; if ( interpolator >= 1 ) { interpolator = - 1 ; } transform . position = Vector3 . Lerp ( startPoint , endPoint , interpolator < 0 ? - interpolator : interpolator ); } ?: or Ternary Conditional Operator The structure with the form x < y ? a : b is a handy shortcut : we test if x is smaller than y (or any other comparison we need here), and return a if true and b if false. Here give the Lerp() function the negative of interpolator if it's smaller than zero, thus making it actually positive again. If interpolator already is positive, it is directly given to Lerp() . Enter this code, save it, and run the game:","title":"Interpolation"},{"location":"1-first-project/#interplay","text":"You can now see the cube moving from side to side, while still spinning from its Rotating script! As before, you can play around with the parameters to change the speed (of both the rotation and translation) and with the starting and end points. You can also disable any of the two scripts at any time during the game by clicking their checkmark, which will freeze their execution and stop them influencing the cube.","title":"Interplay"},{"location":"1-first-project/#connecting-objects","text":"Instead of this mad spinning, let's make this cube rotate face the camera at all times instead.","title":"Connecting objects"},{"location":"1-first-project/#looking-at","text":"First, deactivate the Rotating component while outside the game mode, so that this change sticks. Then, let's add two lines to our Moving script: Moving.cs public class Moving : MonoBehaviour { [Tooltip(\"Units per second\")] public float speed = 1.0f ; [Tooltip(\"Starting position in 3D space\")] public Vector3 startPoint = new Vector3 ( 2 , 0 , - 1 ); [Tooltip(\"End position in 3D space\")] public Vector3 endPoint = new Vector3 ( 2 , 0 , 1 ); [Tooltip(\"Object to face\")] public Transform targetObject ; [SerializeField] private float interpolator = - 1.0f ; // Update is called once per frame void Update () { interpolator += speed * Time . deltaTime ; if ( interpolator >= 1 ) { interpolator = - 1 ; } transform . position = Vector3 . Lerp ( startPoint , endPoint , interpolator < 0 ? - interpolator : interpolator ); transform . LookAt ( targetObject ); } We now gave it a new variable ( targetObject ), this time a Transform . This lets us reference any other GameObject's transform, and therefore e.g. its position. The new last line within the Update() loop uses the LookAt() method from the transform class, which will orient the current GameObject's transform to\u2026 look at, or face in the direction of another transform that we give it.","title":"Looking at"},{"location":"1-first-project/#referencing-objects","text":"Note how we did not initialize this variable in the code; we will instead assign it from the inspector. One way to do it is to click the target icon that now sits in the new variable field in the cube's inspector and select the Main Camera object from the list that appears, or simply drag the Main Camera from the hierarchy into the field: We can see the cube now moving from side to side and always facing the camera if we play it, but to display this new behavior more clearly we can arrange our Unity editor to show the scene and game views at the same time to have an external view. Changing the starting and end points, or the position of the camera will not hinder from lookAt always adjusting the cube's position correctly: If everything works and you've understood every part, you should have now have the basics of Unity down, congratulations! Now onwards to some actual VR \u2014 expect less handholding from now on ;-) Ask for help Remember, if anything is unclear or doesn't work: don't hesitate to ask the tutors.","title":"Referencing objects"},{"location":"2-vr-interaction/","text":"Interaction in VR Let's now dig into actually using VR with Unity, starting with basic interactions! Pre-flight inspection For that we need to add some additional packages to Unity which will be specific to the hardware we're using for this tutorial \u2014 the HTC Vive Pro Eye , using SteamVR. You should verify the proper connection of the headset and the pairing of controllers by opening the Steam application and launching SteamVR. It may ask you to Update Permissions on first launch \u2014 do it by allowing the changes. If everything works, you can see the empty VR space and your controller(s) if you put on the headset, and in an optional desktop view of the VR environment you can enable from the menu button in the SteamVR window: A new project Let's first of all create a new Unity 3D project with the hub, like before. You can close the one from the previous tutorial, we won't be needing it anymore. Set up the new project's window like we did for the first tutorial, or to your own liking. Reusing the old project You can also reuse your old project in this case, just delete both the new objects and assets you created by right-clicking them in the hierarchy and project browser, respectively, and selecting \"delete.\" Or you can also keep them around, as long they're deactivated in the hierarchy \u2014 it's up to you how much clutter you can tolerate vs. how much time you want to save. It can be good to have a working reference around to compare. Installing and importing Packages In the Unity editor's menu bar, go to Window \u2192 Package Manager , which will open a new floating window. Selecting My Assets from the Packages drop-down menu at the top, type in steamvr in the search box and you should have the SteamVR Plugin appear \u2014 import it with the Import button below. A new window will present itself to let you select parts of the package, but we will just keep everything checked and hit Import again. The Asset Store If SteamVR can not be found anywhere in the Package Manager, it may not be added yet to this Unity account. In that case go to the Unity Asset store, find it there, and add it to \"your assets.\" During this, some dialog boxes may appear \u2014 just confirm what they want. SteamVR may ask to accept changes to the project's settings \u2014 Accept All and it will be very happy. You can close the package manager windows now. Having the basics for VR installed with the SteamVR package, we now need an additional one for the eye tracker. You could download it from the developer's website , but we have already put it in a folder on your desktop. To import a package (or an asset ) that is not listed in the package manager, you need to go to Assets \u2192 Import Package \u2192 Custom Package\u2026 in the menu bar. Navigate to the packages folder in the workshop folder and locate Vive-SRanipal-Unity-Plugin.unitypackage under packages \u2192 SDK-v1.3.3.0 \u2192 SDK \u2192 02_Unity . Confirm with Open and you'll be presented with the same interface as before to select only parts of it \u2014 again, keep all checked and Import . Adding VR basics Now that we have the necessary packages all imported, we can add the bare necessities to our scene for VR to function. The Camera Rig The SteamVR package includes everything we need to run VR in Unity, but to access the functionalities we need to add its assets to our scene/hierarchy. Specifically, we need the CameraRig Prefab , which contains pre-configured objects that will correspond with the VR headset and controllers. Add it by finding the SteamVR folder in the Assets folder with the Project browser. Inside that, there's a folder called Prefabs , which contains all its\u2026 Prefabs , which are \"GameObjects complete with all its components, property values, and child GameObjects as [\u2026] reusable Asset[s].\" Locate the [CameraRig] prefab, and simply drag it to an empty are in the hierarchy: Being a prefab, it will appear blue in the hierarchy. Inside it you can find objects named Controller (left) , Controller (right) , and Camera if you expand it by clicking the arrow next to [CameraRig] . This new Camera object will be our main camera from now on, so you can delete the old, default Main Camera object from the hierarchy. First VR run You can already try running the game to see an empty Unity world in VR. The first time you do, a SteamVR window will appear and ask you to \"open the SteamVR Input window\" to generate \"actions for SteamVR\" \u2014 do it. Click through this and the next window with Yes , and hit Save and generate in the new SteamVR Input window that appears in Unity to generate the default inputs bindings for controls; you can close this window afterwards. You may see some error messages in the console because these actions were missing \u2014 run the game again and they should be gone. The headset should be functioning and showing you an empty, sunny world! Interacting with objects \u2014 Part 1 Nice as that may be, we want more. Let's add some objects to interact with. Adding objects Stop the game and start by adding a floor. As before with the cube, right-click somewhere in the hierarchy, select 3D Object , and then find Plane . This will create a flat surface in the middle of our environment. Make sure it's at the origin (Position: X=0, Y=0, Z=0 ) and not rotated, and adjust its scale to X=0.5, Y=1, Z=0.5 . Add a cylinder the same way and place it at X=1.2, Y=0.55, Z=0.5 with a scale of 0.5, 0.5, 0.5 . Create a new cube and scale it to 0.15, 0.15, 0.15 . Copy it by right-clicking on it and selecting Duplicate \u2014 the new one will automatically be named Cube (1) , which you can keep or rename to your liking, e.g. Left Cube and Right Cube . Tying objects to VR controllers Now we want these two cubes to follow the movement of our VR controllers. The easiest way to do this is to simply drag them in the hierarchy to their respective controller objects in the CameraRig, making sure that they end up \"inside\" them: Running the game now you should have a clumsy, white box surrounding the tips of your controllers, with a cylinder standing close by. If you want, you can adjust the transforms of each cube to offset them from the controllers: 0.15 on the Z-axis should look good enough. Materials and colors Let's spice this blank world up a bit by adding some color. Create new folder inside the Assets in the project browser by right-clicking the Assets folder, then Create \u2192 Folder . Name it Materials . Inside this folder, create two new Materials : Create \u2192 Material . Name them BlueBox and RedBox . Clicking on them you see their properties in the inspector \u2014 change the Albedo of BlueBox to a blue color, and that of RedBox to a red one by clicking on the white strip. You can see the changes in the preview sphere at the bottom of a material's inspector. You can now assign these materials to the cubes by going to each cube's inspector, expanding the Materials property in its Mesh Renderer component, and either dragging a material there, or selecting one by clicking the target icon. Choose which cube should be red, and which blue, and make these changes. Rigidbody Components While you can now wave around with colorful boxes, there is not much else going on \u2014 the cylinder just stands there, oblivious to anything you do (try it, the cubes and controllers will just intersect it in a ghostly fashion). We can change that by giving the objects in our scene Rigidbody components, which will add physics and automatic collision detection to them. In the hierarchy, select our smaller objects (the cylinder and both cubes) by holding CTRL and clicking on each. The inspector now shows properties that are shared for all objects, and allows you to add components in bulk. Click Add Component with all three objects (and nothing else!) selected, and search for the Ridgidbody component. We want our cubes to still only be controlled by being tied to our controllers and not be affected by gravity, so go to the hierarchy, de select the cylinder and select only the two cubes. In their Rigidbody component, uncheck Use Gravity and place a checkmark on Is Kinematic . The cylinder on the other hand should behave as a real physical object, so do the inverse for it: make sure Use Gravity is on, and Is Kinematic is off. Run the game and observe the changes: the cylinder should now sit flush on the floor, and you can now use the cubes attached to your controllers to whack it! Hit hard enough and it falls off the floor plane and down to the endless abyss. Interacting with objects \u2014 Part 2 Other uses of Rigidbody Sending objects flying is fun, but there are other uses of the Rigidbody component. As mentioned before, there is collision detection . It relies on there being a Collider component present in both objects, and a Rigidbody in at least one of them. We now need to configure this. Let's be more gentle to the cylinder and remove its Rigidbody component by clicking on its three dots and selecting Remove Component . Make sure it still as its Capsule Collider component. Select the two cubes again and inspect their Box Collider components and set a checkmark in the field Is Trigger . We can now be informed about collisions between our cubes and the cylinder in code. An array of Materials Create another new folder within Assets, and name it Scripts. In it, create a new C# Script called SwitchMaterialOnCollide . We want this script to give our cylinder a number of materials that it will switch between whenever a collision is detected. Open the script in the code editor, and add some lines to create a public and a private variable: SwitchMaterialOnCollide.cs public class SwitchMaterialOnCollide : MonoBehaviour { public Material [] materials ; private MeshRenderer _meshRenderer ; } The variable Material is an Array , which is set by placing two square brackets right after the variable name declaration. This means it is actually a container of multiple materials, the number of which is not set. Save the code file and go back to the Unity editor to attach this code as a component to the cylinder by just dragging the file's icon from the project browser onto the cylinder object in the hierarchy. You will now see the a Switch Material On Collide component in the cylinder's inspector, showing only Materials as an editable field \u2014 the second variable, _meshRenderer , is private and not visible here. Expand this field with its arrow, and add increase the number of Elements this array of materials can hold by either entering 2 directly where there is currently a 0 , or by clicking the + button twice. You can now place our red and blue materials in these fields: MeshRenderer and its Material Go back to the code editor and add two lines to the Start() function: SwitchMaterialOnCollide.cs using UnityEngine ; public class SwitchMaterialOnCollide : MonoBehaviour { public Material [] materials ; private MeshRenderer _meshRenderer ; // Start is called before the first frame update void Start () { _meshRenderer = GetComponent < MeshRenderer >(); _meshRenderer . material = materials [ 0 ]; } } Here, we assign the _meshRenderer variable declared above with the MeshRenderer component that's already attached to the cylinder. This works because the SwitchMaterialOnCollide script is attached to the cylinder object, and the GetComponent<MeshRenderer>() function searches through all components of the current GameObject and returns the first one that is of the type MeshRenderer . You can find this very component in the cylinder's inspector. As its name implies, the MeshRenderer is the component of a GameObject that's responsible to render its mesh, i.e., making the its geometric shape visible on screen. Among its many parameters is the Material it uses, which is always set to Default-Material for any new 3D object you create. The second line in our Start() function \u2014 _meshRenderer.material = materials[0]; now reassigns this default value to whatever we've put in the first place (at index 0 ) of our materials[] array of the Switch Material On Collide component every time we start the game. In the video above that would be the BlueBox material. Try it out: the cylinder should now be blue when you run the game! It will revert back to the white Default Material when you stop the game. Collision triggers Now let's have the cylinder change its material not just on startup, but when we \"physically\" interact with it in VR. Add two new functions to our SwitchMaterialOnCollide script (outside the scope of Start() , but still inside the MonoBehavior ): SwitchMaterialOnCollide.cs using UnityEngine ; public class SwitchMaterialOnCollide : MonoBehaviour { public Material [] materials ; private MeshRenderer _meshRenderer ; // Start is called before the first frame update void Start () { _meshRenderer = GetComponent < MeshRenderer >(); _meshRenderer . material = materials [ 0 ]; } private void OnTriggerEnter ( Collider other ) { _meshRenderer . material = materials [ 1 ]; } private void OnTriggerExit ( Collider other ) { _meshRenderer . material = materials [ 0 ]; } } The functions OnTriggerEnter() and OnTriggerLeave() are called when their GameObject collides with another one that has a Rigidbody attached, and a collider which is set to be a Trigger \u2014 we already did this with our cubes above . Run the game now and you can change the cylinder's material when you hit them with any of the cubes! Switching colors of a material For now we've just switched between different materials to change the color of the cylinder, which could be considered wasteful. Why create a whole new material asset, when all we want to do is just change the color? Create a new script called SwitchColorOnCollide and attach it to the cylinder. Remove the old Switch Material On Collide component from it. SwitchColorOnCollide.cs using UnityEngine ; public class SwitchColorOnCollide : MonoBehaviour { public Color [] colors ; private Material _material ; // Start is called before the first frame update void Start () { _material = GetComponent < MeshRenderer >(). material ; _material . color = colors [ 0 ]; } private void OnTriggerEnter ( Collider other ) { _material . color = colors [ 1 ]; } private void OnTriggerExit ( Collider other ) { _material . color = colors [ 0 ]; } } The basic structure is the same as in SwitchMaterialOnCollide.cs , but note the differences: We now store an array of Colors in the variable colors We get the Material from the cylinder's MeshRenderer by calling .material on the output of the GetComponent<>() function We assign one of our stored colors to the MeshRenderer's material You can now directly set two different colors in the new Switch Material On Collide component (after you've saved the code), the same way we input colors for the two box materials . Run the game again and see how the cylinder now changes its default material's colors to our choice: Once again, all changes to the default material will be reverted once we end the game. Challenge \u2014 do it yourself! Create two new Sphere 3D objects and attach these to the controllers instead of the cubes, which you can remove. Give them the same functionalities as the cubes (Rigidbodies and Colliders with the same parameters). Shape and place them using their Transforms to roughly overlap with the controllers: you can do this while the game is running to see your changes, and once you have good values write them down to make them permanent outside of the game. You can copy one component's values to another by clicking its three-dot menu and selecing Copy or Paste. Once this works, try disabling the spheres' Sphere (Mesh Filter) and Mesh Renderer components: you will not see the spheres anymore, but they will still work in changing the colors of the cylinder! Interacting with objects \u2014 Part 3 For this last part of object interaction (for now), let's use something other than just the controllers' position to interact with the world. Maybe you've already noticed, but there are a lot of buttons on them \u2014 why not try them? Inter-script interaction Let's first add another function to our SwitchColorOnCollide script: SwitchColorOnCollide.cs using UnityEngine ; public class SwitchColorOnCollide : MonoBehaviour { public Color [] colors ; private Material _material ; // Start is called before the first frame update void Start () { _material = GetComponent < MeshRenderer >(). material ; _material . color = colors [ 0 ]; } private void OnTriggerEnter ( Collider other ) { _material . color = colors [ 1 ]; } private void OnTriggerExit ( Collider other ) { _material . color = colors [ 0 ]; } public void SetColor ( int index ) { if ( index < 0 || index >= colors . Length ) { return ; } _material . color = colors [ index ]; } } Being public , the SetColor() function can be called by other outside scripts. In addition, it takes an input parameter (int index) , an integer which it uses to select a color from our array of colors to assign to the main material. The line if ( index < 0 || index >= colors . Length ) { return ; } is actually three lines shortened to one: an if() statement that checks whether the given index is smaller than zero or larger than our array of colors; if so: do nothing and escape this function {return; } . This is to prevent anything from going wrong if an external script gives it the wrong input \u2014 very important! Save the file. SteamVR Actions Let's now write a script that will call this public function. Create a new one named ControllerInput and attach it to the [CameraRig] GameObject: ControllerInput.cs using UnityEngine ; using Valve.VR ; public class ControllerInput : MonoBehaviour { public SteamVR_Action_Boolean Trigger ; public SwitchColorOnCollide switchColorOnCollide ; // Update is called once per frame void Update () { if ( Trigger . state ) { switchColorOnCollide . SetColor ( 1 ); } else { switchColorOnCollide . SetColor ( 0 ); } } } We have now also added a new Library to use: Valve.VR , which gives us access to specific functions for our VR devices, such as the SteamVR_Action_Boolean class. We Create a variable Trigger that will listen to actions from our VR hardware, in this case Boolean -type events (on or off). Since our previously created SwitchColorOnCollide script is a public class , we can also reference its definition here and create a variable of its class, which we call (lowercase) switchColorOnCollide . In the Update() loop (every frame) we now want to check the Trigger 's state : if it's true, we tell our switchColorOnCollide object to set its color to the one it has at index 1 , and if it's false, to the one at index 0 . Take a moment to understand this, and feel free to ask if you have questions. Save the script and return to Unity. As it is, it will not do anything: neither its Trigger or its Switch Color On Collide parameters are assigned yet. Fix this by giving the Trigger a default value from the SteamVR SDK ( \\actions\\default\\in\\InteractUI ), and the put the cylinder's Switch Color On Collide component in the second field. You can do this by searching for it among the objects in the current scene by clicking the target icon, or by simply dragging the whole cylinder object into it \u2014 it's smart enough to only take the relevant component from the cylinder. Run the game. Now you can simply press the triggers on you controllers to change the cylinder's color! InteractUI and Bindings The way our trigger can interact here is because of the default bindings we are using here, which map the controller's buttons to actions ( more info from Valve ). If you access the \"Old Bindings UI\" inside the headset's VR view using the menu button, you can see how the trigger is configured to output the InteractUI action, which itself is interpreted by Unity as a boolean input ( Window \u2192 SteamVR Input ). All this is fully configurable, but would exceed the scope of this initial tutorial. Onwards to more complex \u2014 and fully automated \u2014 scenes!","title":"2 \u2022\u00a0Interaction in VR"},{"location":"2-vr-interaction/#interaction-in-vr","text":"Let's now dig into actually using VR with Unity, starting with basic interactions!","title":"Interaction in VR"},{"location":"2-vr-interaction/#pre-flight-inspection","text":"For that we need to add some additional packages to Unity which will be specific to the hardware we're using for this tutorial \u2014 the HTC Vive Pro Eye , using SteamVR. You should verify the proper connection of the headset and the pairing of controllers by opening the Steam application and launching SteamVR. It may ask you to Update Permissions on first launch \u2014 do it by allowing the changes. If everything works, you can see the empty VR space and your controller(s) if you put on the headset, and in an optional desktop view of the VR environment you can enable from the menu button in the SteamVR window:","title":"Pre-flight inspection"},{"location":"2-vr-interaction/#a-new-project","text":"Let's first of all create a new Unity 3D project with the hub, like before. You can close the one from the previous tutorial, we won't be needing it anymore. Set up the new project's window like we did for the first tutorial, or to your own liking. Reusing the old project You can also reuse your old project in this case, just delete both the new objects and assets you created by right-clicking them in the hierarchy and project browser, respectively, and selecting \"delete.\" Or you can also keep them around, as long they're deactivated in the hierarchy \u2014 it's up to you how much clutter you can tolerate vs. how much time you want to save. It can be good to have a working reference around to compare.","title":"A new project"},{"location":"2-vr-interaction/#installing-and-importing-packages","text":"In the Unity editor's menu bar, go to Window \u2192 Package Manager , which will open a new floating window. Selecting My Assets from the Packages drop-down menu at the top, type in steamvr in the search box and you should have the SteamVR Plugin appear \u2014 import it with the Import button below. A new window will present itself to let you select parts of the package, but we will just keep everything checked and hit Import again. The Asset Store If SteamVR can not be found anywhere in the Package Manager, it may not be added yet to this Unity account. In that case go to the Unity Asset store, find it there, and add it to \"your assets.\" During this, some dialog boxes may appear \u2014 just confirm what they want. SteamVR may ask to accept changes to the project's settings \u2014 Accept All and it will be very happy. You can close the package manager windows now. Having the basics for VR installed with the SteamVR package, we now need an additional one for the eye tracker. You could download it from the developer's website , but we have already put it in a folder on your desktop. To import a package (or an asset ) that is not listed in the package manager, you need to go to Assets \u2192 Import Package \u2192 Custom Package\u2026 in the menu bar. Navigate to the packages folder in the workshop folder and locate Vive-SRanipal-Unity-Plugin.unitypackage under packages \u2192 SDK-v1.3.3.0 \u2192 SDK \u2192 02_Unity . Confirm with Open and you'll be presented with the same interface as before to select only parts of it \u2014 again, keep all checked and Import .","title":"Installing and importing Packages"},{"location":"2-vr-interaction/#adding-vr-basics","text":"Now that we have the necessary packages all imported, we can add the bare necessities to our scene for VR to function.","title":"Adding VR basics"},{"location":"2-vr-interaction/#the-camera-rig","text":"The SteamVR package includes everything we need to run VR in Unity, but to access the functionalities we need to add its assets to our scene/hierarchy. Specifically, we need the CameraRig Prefab , which contains pre-configured objects that will correspond with the VR headset and controllers. Add it by finding the SteamVR folder in the Assets folder with the Project browser. Inside that, there's a folder called Prefabs , which contains all its\u2026 Prefabs , which are \"GameObjects complete with all its components, property values, and child GameObjects as [\u2026] reusable Asset[s].\" Locate the [CameraRig] prefab, and simply drag it to an empty are in the hierarchy: Being a prefab, it will appear blue in the hierarchy. Inside it you can find objects named Controller (left) , Controller (right) , and Camera if you expand it by clicking the arrow next to [CameraRig] . This new Camera object will be our main camera from now on, so you can delete the old, default Main Camera object from the hierarchy.","title":"The Camera Rig"},{"location":"2-vr-interaction/#first-vr-run","text":"You can already try running the game to see an empty Unity world in VR. The first time you do, a SteamVR window will appear and ask you to \"open the SteamVR Input window\" to generate \"actions for SteamVR\" \u2014 do it. Click through this and the next window with Yes , and hit Save and generate in the new SteamVR Input window that appears in Unity to generate the default inputs bindings for controls; you can close this window afterwards. You may see some error messages in the console because these actions were missing \u2014 run the game again and they should be gone. The headset should be functioning and showing you an empty, sunny world!","title":"First VR run"},{"location":"2-vr-interaction/#interacting-with-objects-part-1","text":"Nice as that may be, we want more. Let's add some objects to interact with.","title":"Interacting with objects \u2014\u00a0Part 1"},{"location":"2-vr-interaction/#adding-objects","text":"Stop the game and start by adding a floor. As before with the cube, right-click somewhere in the hierarchy, select 3D Object , and then find Plane . This will create a flat surface in the middle of our environment. Make sure it's at the origin (Position: X=0, Y=0, Z=0 ) and not rotated, and adjust its scale to X=0.5, Y=1, Z=0.5 . Add a cylinder the same way and place it at X=1.2, Y=0.55, Z=0.5 with a scale of 0.5, 0.5, 0.5 . Create a new cube and scale it to 0.15, 0.15, 0.15 . Copy it by right-clicking on it and selecting Duplicate \u2014 the new one will automatically be named Cube (1) , which you can keep or rename to your liking, e.g. Left Cube and Right Cube .","title":"Adding objects"},{"location":"2-vr-interaction/#tying-objects-to-vr-controllers","text":"Now we want these two cubes to follow the movement of our VR controllers. The easiest way to do this is to simply drag them in the hierarchy to their respective controller objects in the CameraRig, making sure that they end up \"inside\" them: Running the game now you should have a clumsy, white box surrounding the tips of your controllers, with a cylinder standing close by. If you want, you can adjust the transforms of each cube to offset them from the controllers: 0.15 on the Z-axis should look good enough.","title":"Tying objects to VR controllers"},{"location":"2-vr-interaction/#materials-and-colors","text":"Let's spice this blank world up a bit by adding some color. Create new folder inside the Assets in the project browser by right-clicking the Assets folder, then Create \u2192 Folder . Name it Materials . Inside this folder, create two new Materials : Create \u2192 Material . Name them BlueBox and RedBox . Clicking on them you see their properties in the inspector \u2014 change the Albedo of BlueBox to a blue color, and that of RedBox to a red one by clicking on the white strip. You can see the changes in the preview sphere at the bottom of a material's inspector. You can now assign these materials to the cubes by going to each cube's inspector, expanding the Materials property in its Mesh Renderer component, and either dragging a material there, or selecting one by clicking the target icon. Choose which cube should be red, and which blue, and make these changes.","title":"Materials and colors"},{"location":"2-vr-interaction/#rigidbody-components","text":"While you can now wave around with colorful boxes, there is not much else going on \u2014 the cylinder just stands there, oblivious to anything you do (try it, the cubes and controllers will just intersect it in a ghostly fashion). We can change that by giving the objects in our scene Rigidbody components, which will add physics and automatic collision detection to them. In the hierarchy, select our smaller objects (the cylinder and both cubes) by holding CTRL and clicking on each. The inspector now shows properties that are shared for all objects, and allows you to add components in bulk. Click Add Component with all three objects (and nothing else!) selected, and search for the Ridgidbody component. We want our cubes to still only be controlled by being tied to our controllers and not be affected by gravity, so go to the hierarchy, de select the cylinder and select only the two cubes. In their Rigidbody component, uncheck Use Gravity and place a checkmark on Is Kinematic . The cylinder on the other hand should behave as a real physical object, so do the inverse for it: make sure Use Gravity is on, and Is Kinematic is off. Run the game and observe the changes: the cylinder should now sit flush on the floor, and you can now use the cubes attached to your controllers to whack it! Hit hard enough and it falls off the floor plane and down to the endless abyss.","title":"Rigidbody Components"},{"location":"2-vr-interaction/#interacting-with-objects-part-2","text":"","title":"Interacting with objects \u2014\u00a0Part 2"},{"location":"2-vr-interaction/#other-uses-of-rigidbody","text":"Sending objects flying is fun, but there are other uses of the Rigidbody component. As mentioned before, there is collision detection . It relies on there being a Collider component present in both objects, and a Rigidbody in at least one of them. We now need to configure this. Let's be more gentle to the cylinder and remove its Rigidbody component by clicking on its three dots and selecting Remove Component . Make sure it still as its Capsule Collider component. Select the two cubes again and inspect their Box Collider components and set a checkmark in the field Is Trigger . We can now be informed about collisions between our cubes and the cylinder in code.","title":"Other uses of Rigidbody"},{"location":"2-vr-interaction/#an-array-of-materials","text":"Create another new folder within Assets, and name it Scripts. In it, create a new C# Script called SwitchMaterialOnCollide . We want this script to give our cylinder a number of materials that it will switch between whenever a collision is detected. Open the script in the code editor, and add some lines to create a public and a private variable: SwitchMaterialOnCollide.cs public class SwitchMaterialOnCollide : MonoBehaviour { public Material [] materials ; private MeshRenderer _meshRenderer ; } The variable Material is an Array , which is set by placing two square brackets right after the variable name declaration. This means it is actually a container of multiple materials, the number of which is not set. Save the code file and go back to the Unity editor to attach this code as a component to the cylinder by just dragging the file's icon from the project browser onto the cylinder object in the hierarchy. You will now see the a Switch Material On Collide component in the cylinder's inspector, showing only Materials as an editable field \u2014 the second variable, _meshRenderer , is private and not visible here. Expand this field with its arrow, and add increase the number of Elements this array of materials can hold by either entering 2 directly where there is currently a 0 , or by clicking the + button twice. You can now place our red and blue materials in these fields:","title":"An array of Materials"},{"location":"2-vr-interaction/#meshrenderer-and-its-material","text":"Go back to the code editor and add two lines to the Start() function: SwitchMaterialOnCollide.cs using UnityEngine ; public class SwitchMaterialOnCollide : MonoBehaviour { public Material [] materials ; private MeshRenderer _meshRenderer ; // Start is called before the first frame update void Start () { _meshRenderer = GetComponent < MeshRenderer >(); _meshRenderer . material = materials [ 0 ]; } } Here, we assign the _meshRenderer variable declared above with the MeshRenderer component that's already attached to the cylinder. This works because the SwitchMaterialOnCollide script is attached to the cylinder object, and the GetComponent<MeshRenderer>() function searches through all components of the current GameObject and returns the first one that is of the type MeshRenderer . You can find this very component in the cylinder's inspector. As its name implies, the MeshRenderer is the component of a GameObject that's responsible to render its mesh, i.e., making the its geometric shape visible on screen. Among its many parameters is the Material it uses, which is always set to Default-Material for any new 3D object you create. The second line in our Start() function \u2014 _meshRenderer.material = materials[0]; now reassigns this default value to whatever we've put in the first place (at index 0 ) of our materials[] array of the Switch Material On Collide component every time we start the game. In the video above that would be the BlueBox material. Try it out: the cylinder should now be blue when you run the game! It will revert back to the white Default Material when you stop the game.","title":"MeshRenderer and its Material"},{"location":"2-vr-interaction/#collision-triggers","text":"Now let's have the cylinder change its material not just on startup, but when we \"physically\" interact with it in VR. Add two new functions to our SwitchMaterialOnCollide script (outside the scope of Start() , but still inside the MonoBehavior ): SwitchMaterialOnCollide.cs using UnityEngine ; public class SwitchMaterialOnCollide : MonoBehaviour { public Material [] materials ; private MeshRenderer _meshRenderer ; // Start is called before the first frame update void Start () { _meshRenderer = GetComponent < MeshRenderer >(); _meshRenderer . material = materials [ 0 ]; } private void OnTriggerEnter ( Collider other ) { _meshRenderer . material = materials [ 1 ]; } private void OnTriggerExit ( Collider other ) { _meshRenderer . material = materials [ 0 ]; } } The functions OnTriggerEnter() and OnTriggerLeave() are called when their GameObject collides with another one that has a Rigidbody attached, and a collider which is set to be a Trigger \u2014 we already did this with our cubes above . Run the game now and you can change the cylinder's material when you hit them with any of the cubes!","title":"Collision triggers"},{"location":"2-vr-interaction/#switching-colors-of-a-material","text":"For now we've just switched between different materials to change the color of the cylinder, which could be considered wasteful. Why create a whole new material asset, when all we want to do is just change the color? Create a new script called SwitchColorOnCollide and attach it to the cylinder. Remove the old Switch Material On Collide component from it. SwitchColorOnCollide.cs using UnityEngine ; public class SwitchColorOnCollide : MonoBehaviour { public Color [] colors ; private Material _material ; // Start is called before the first frame update void Start () { _material = GetComponent < MeshRenderer >(). material ; _material . color = colors [ 0 ]; } private void OnTriggerEnter ( Collider other ) { _material . color = colors [ 1 ]; } private void OnTriggerExit ( Collider other ) { _material . color = colors [ 0 ]; } } The basic structure is the same as in SwitchMaterialOnCollide.cs , but note the differences: We now store an array of Colors in the variable colors We get the Material from the cylinder's MeshRenderer by calling .material on the output of the GetComponent<>() function We assign one of our stored colors to the MeshRenderer's material You can now directly set two different colors in the new Switch Material On Collide component (after you've saved the code), the same way we input colors for the two box materials . Run the game again and see how the cylinder now changes its default material's colors to our choice: Once again, all changes to the default material will be reverted once we end the game. Challenge \u2014 do it yourself! Create two new Sphere 3D objects and attach these to the controllers instead of the cubes, which you can remove. Give them the same functionalities as the cubes (Rigidbodies and Colliders with the same parameters). Shape and place them using their Transforms to roughly overlap with the controllers: you can do this while the game is running to see your changes, and once you have good values write them down to make them permanent outside of the game. You can copy one component's values to another by clicking its three-dot menu and selecing Copy or Paste. Once this works, try disabling the spheres' Sphere (Mesh Filter) and Mesh Renderer components: you will not see the spheres anymore, but they will still work in changing the colors of the cylinder!","title":"Switching colors of a material"},{"location":"2-vr-interaction/#interacting-with-objects-part-3","text":"For this last part of object interaction (for now), let's use something other than just the controllers' position to interact with the world. Maybe you've already noticed, but there are a lot of buttons on them \u2014 why not try them?","title":"Interacting with objects \u2014\u00a0Part 3"},{"location":"2-vr-interaction/#inter-script-interaction","text":"Let's first add another function to our SwitchColorOnCollide script: SwitchColorOnCollide.cs using UnityEngine ; public class SwitchColorOnCollide : MonoBehaviour { public Color [] colors ; private Material _material ; // Start is called before the first frame update void Start () { _material = GetComponent < MeshRenderer >(). material ; _material . color = colors [ 0 ]; } private void OnTriggerEnter ( Collider other ) { _material . color = colors [ 1 ]; } private void OnTriggerExit ( Collider other ) { _material . color = colors [ 0 ]; } public void SetColor ( int index ) { if ( index < 0 || index >= colors . Length ) { return ; } _material . color = colors [ index ]; } } Being public , the SetColor() function can be called by other outside scripts. In addition, it takes an input parameter (int index) , an integer which it uses to select a color from our array of colors to assign to the main material. The line if ( index < 0 || index >= colors . Length ) { return ; } is actually three lines shortened to one: an if() statement that checks whether the given index is smaller than zero or larger than our array of colors; if so: do nothing and escape this function {return; } . This is to prevent anything from going wrong if an external script gives it the wrong input \u2014 very important! Save the file.","title":"Inter-script interaction"},{"location":"2-vr-interaction/#steamvr-actions","text":"Let's now write a script that will call this public function. Create a new one named ControllerInput and attach it to the [CameraRig] GameObject: ControllerInput.cs using UnityEngine ; using Valve.VR ; public class ControllerInput : MonoBehaviour { public SteamVR_Action_Boolean Trigger ; public SwitchColorOnCollide switchColorOnCollide ; // Update is called once per frame void Update () { if ( Trigger . state ) { switchColorOnCollide . SetColor ( 1 ); } else { switchColorOnCollide . SetColor ( 0 ); } } } We have now also added a new Library to use: Valve.VR , which gives us access to specific functions for our VR devices, such as the SteamVR_Action_Boolean class. We Create a variable Trigger that will listen to actions from our VR hardware, in this case Boolean -type events (on or off). Since our previously created SwitchColorOnCollide script is a public class , we can also reference its definition here and create a variable of its class, which we call (lowercase) switchColorOnCollide . In the Update() loop (every frame) we now want to check the Trigger 's state : if it's true, we tell our switchColorOnCollide object to set its color to the one it has at index 1 , and if it's false, to the one at index 0 . Take a moment to understand this, and feel free to ask if you have questions. Save the script and return to Unity. As it is, it will not do anything: neither its Trigger or its Switch Color On Collide parameters are assigned yet. Fix this by giving the Trigger a default value from the SteamVR SDK ( \\actions\\default\\in\\InteractUI ), and the put the cylinder's Switch Color On Collide component in the second field. You can do this by searching for it among the objects in the current scene by clicking the target icon, or by simply dragging the whole cylinder object into it \u2014 it's smart enough to only take the relevant component from the cylinder. Run the game. Now you can simply press the triggers on you controllers to change the cylinder's color! InteractUI and Bindings The way our trigger can interact here is because of the default bindings we are using here, which map the controller's buttons to actions ( more info from Valve ). If you access the \"Old Bindings UI\" inside the headset's VR view using the menu button, you can see how the trigger is configured to output the InteractUI action, which itself is interpreted by Unity as a boolean input ( Window \u2192 SteamVR Input ). All this is fully configurable, but would exceed the scope of this initial tutorial. Onwards to more complex \u2014 and fully automated \u2014 scenes!","title":"SteamVR Actions"},{"location":"3-runtime/","text":"Runtime: Automated Processes For now, our scenes have only strictly reacted to our inputs. Let's create some automated processes. Reuse the previous project For this project, let's continue building on our previous one, without having to again import the libraries and creating our cubes or spheres (from the previous challenge ) that trigger collisions. Just remove (or deactivate) the cylinder GameObject from the hierarchy and delete the Controller Input (Script) component from our [CameraRig] GameObject. Shape of a cube factory What's a better example for automation than a factory? Let's make a cube factory. Create a new, empty GameObject in the hierarchy (\"Create Empty\") and name it CubeFactory . Place it at (-1, 0, -0.25) . Now right-click on it to create child objects within it: six new cubes. Their names, positions, and scales should be as below. Editing Time Savers You can quickly enter these numbers by hitting the Tab-key after entering each one, which will advance the focus to the next field. You can also save time by omitting the zeros before periods: the editor will fill them in automatically. \"CubeRight\" Position (0, 0.9, 0) Scale (0.5, 1.8, 0.25) \"CubeLeft\" Position (0, 0.9, 0.5) Scale (0.5, 1.8, 0.25) \"CubeBack\" Position (-0.2, 0.9, 0.25) Scale (0.1, 1.8, 0.25) \"CubeSlope\" Position (0, 0.125, 0.25) Rotation (0, 0, 55) Scale (0.1, 0.6, 0.25) \"CubeFront\" Position (0.2, 1.175, 0.25) Scale (0.1, 1.25, 0.25) \"CubeInteract\" Position (0.21, 1, 0.25) Scale (0.1, 0.2, 0.2) You should end up with a hollow cuboid that has a sloped opening at its lower end \u2014 kind of like a chimney. \"CubeInteract\" should stick out just a little: Labeling with TextMeshPro Another very useful \"3D Object\" we can add to the factory is Text - TextMeshPro. Create one within the CubeFactory GameObject, and give it the following parameters (it may ask you to import some resources the first time you do that \u2014 let it): Within the Rect Transform component: Position = (0.251, 1.25, 0.25) Width = 70, Height = 20 Rotation = (0, -90, 0) Scale = (0.01, 0.01, 1) Center and middle alignment icons in its TextMeshPro - Text component The following text in place of \"Sample text\": <b>Cube Factory<\\b> Touch the red part with the controller and press the trigger to create a new cube + Set its Vertex Color to anything you like You should now have a helpful label for the cube factory: Factory interaction For now, it's just an empty structure, doing nothing. Let's change that with some action. Create a new script for the cube we called CubeInteract , called IsCollidingChecker . It will be very similar to our old SwitchColorOnCollide script: IsCollidingChecker.cs using UnityEngine ; public class IsCollidingChecker : MonoBehaviour { public bool isColliding ; public Color [] colors ; private Material _material ; // Start is called before the first frame update void Start () { _material = GetComponent < MeshRenderer >(). material ; _material . color = colors [ 0 ]; } private void OnTriggerEnter ( Collider other ) { isColliding = true ; _material . color = colors [ 1 ]; } private void OnTriggerExit ( Collider other ) { isColliding = false ; _material . color = colors [ 0 ]; } } The main difference is that it now exposes its isColliding boolean variable to other objects. This variable is set to True whenever it is in collision, and False when not, while at the same time changing colors. Save the script and assign two colors of your liking to this component as we did before . Running the game, you can now switch the color of the CubeInteract object by hitting it with your controller, and you'll also see its Is Colliding value change accordingly: Factory scripting The factory is still not working as advertised above this fancy button. Let's change that and make some cubes. Create a new script for the CubeFactory object itself, called\u2026 CubeFactory . Script scraps This will be a larger script, so we will from now on only show parts of its code at a time \u2014 by now you should be familiar with which parts belong where. Don't worry about the order of variables and functions: as long as they are within the correct scope (brackets), it does not matter which appear first in your script. We will be using even more libraries now than before, so make sure to include all these using statements at the top. Variables CubeFactory.cs using System.Diagnostics ; using UnityEngine ; using UnityEngine.InputSystem ; using Valve.VR ; Within the CubeFactory class definition, declare the following variables: CubeFactory.cs public IsCollidingChecker isCollidingChecker ; public SteamVR_Action_Boolean Trigger ; private Stopwatch stopwatch ; public int cooldown = 500 ; The first two should already be familiar from our color-changing cylinder . The second two will help us with timing: we only want to let the factory produce cubes at minimum intervals, so we create a Stopwatch to measure passing time, and a cooldown variable that lets us say how long it should rest before pumping out another cube. CubeFactory.cs void Start () { stopwatch = new Stopwatch (); stopwatch . Start (); } At the start of the game, we only initialize the stopwatch variable using the new Stopwatch() command, and start() it immediately. Cube creation Let's now create the function that will actually generate new cubes that interact with physics, and with random colors to boot! CubeFactory.cs public GameObject CreateCube () { GameObject cubeGo = GameObject . CreatePrimitive ( PrimitiveType . Cube ); Transform cubeTrans = cubeGo . transform ; cubeTrans . position = new Vector3 (- 1f , 0.9f , 0f ); cubeTrans . localScale = new Vector3 (. 15f ,. 15f ,. 15f ); cubeGo . GetComponent < MeshRenderer >(). material . color = Random . ColorHSV (); Rigidbody cubeRB = cubeGo . AddComponent < Rigidbody >(); // Add randomness otherwise cubes will all show the exact same trajectory cubeRB . velocity = new Vector3 ( Random . value * . 1f ,- 1 , Random . value * . 1f ) * 5f ; return cubeGo ; } When called, it creates a new GameObject we call cubeGo by invoking the GameObject class' CreatePrimitive function , with PrimitiveType.Cube as the input. We take this new object's transform and store a reference to it in a new Transform object called cubeTrans , so that we can directly work on it in the next two lines, where we give it a new position and scale. Similar to how we changed the cylinder's or the CubeInteract's colors, we assign cubeGo 's default material a new color, in this case a Random combination of H ue, S aturation, and V alue (brightness). Finally, we add a Rigidbody component to it, to which we also assign a random (within bounds) velocity, to spice things up a bit in their trajectories. Since this function is declared not as void , it is expected to return something, in this case a GameObject (see the first line of the above code \u2014 the function's declaration). We obviously want to return the just created cubeGo object, which is what the last line does. Requesting new cubes We can now go to the Update() loop and a call to our cube production function: CubeFactory.cs // Update is called once per frame void Update () { if ( stopwatch . Elapsed . Milliseconds >= cooldown ) { CreateCube (); stopwatch . Restart (); } } To keep our cube production in check, we must first verify that our set stopwatch has measured enough milliseconds (more than our set cool-down period). Only then will a cube be created, and the stopwatch restarted. Save the code and see it run: the factory's output is in full swing! Trouble with UnityEngine.InputSystem? It may be that your code editor and the Unity complain about a missing UnityEngine.InputSystem . This can be easily fixed by going to the package manager and searching for InputSystem in the Unity Registry . Install it, which will also prompt Unity configure some settings and restart the editor, so make sure to save your changes before doing so. Controlling factory output To avoid a Tribbles-type situation , we need to have some control over the factory's cube output. We can add some more conditions to our if statement in the Update() loop to only allow authorized personnel to run the production: CubeFactory.cs void Update () { if ( stopwatch . Elapsed . Milliseconds >= cooldown && isCollidingChecker . isColliding && Trigger . state ) { CreateCube (); stopwatch . Restart (); } } The And-operator && can be used to chain logic statements together. You can put everything within the round brackets of the if() statement in one line, but this way we preserve legibility of an otherwise unwieldy, long line. Now the if() statement will execute its block if the stopwatch has measured more than cooldown , AND a collision is detected by the CubeInspect object, AND the trigger is pulled. If any one of these conditions is not true, no cubes will be produced. This should keep the factory floor safe. Save the code, go back to the editor, and assign the CubeInteract object's Is Colliding Checker component to the cube factory script component ( like we did with the cylinder ), and set the Trigger again to InteractUI ( see cylinder ). Manual override Often it is good to include a manual override over conditions like we have above for the cube production. You can extend the if() statement with one more clause, this time an OR || operator to make it look like this: if ( stopwatch . Elapsed . Milliseconds >= cooldown && isCollidingChecker . isColliding && Trigger . state || Keyboard . current . spaceKey . wasReleasedThisFrame ) Now the only condition necessary to trigger the production of the next cube the user hitting the space button on the computer that's running Unity (while focused on the Game view), bypassing all other rules. Cubes will be now produced as fast as you can press the space bar \u2014 don't break it! Cube removal Even with controlled production, cubes still pile up eventually. Let's clean them up. Destroyer script Create a new script in the scripts folder without attaching it to any GameObject and name it DestroyOnTouch . We want it to come into action every time our controllers (i.e., their attached cubes or spheres) collide with a freshly produced cube to pop them into oblivion. DestroyOnTouch.cs using System ; using System.Collections ; using UnityEngine ; public class DestroyOnTouch : MonoBehaviour { private void OnTriggerEnter ( Collider other ) { Destroy ( gameObject ); } } The now familiar OnTriggerEnter() function will simply call the Destroy() command on gameObject itself, which refers to the GameObject this script is working within. As it is now, the code just sits in our Scripts folder and does nothing, so let's attach it to all factory-fresh cubes our CubeFactory is producing. Attaching the destroyer To attach this script ( make sure to save it first! ) to new cubes, we simply need to modify the CreateCube() function within CubeFactory : CubeFactory.cs public GameObject CreateCube () { GameObject cubeGo = GameObject . CreatePrimitive ( PrimitiveType . Cube ); Transform cubeTrans = cubeGo . transform ; cubeTrans . position = new Vector3 (- 1f , 0.9f , 0f ); cubeTrans . localScale = new Vector3 (. 15f ,. 15f ,. 15f ); cubeGo . GetComponent < MeshRenderer >(). material . color = Random . ColorHSV (); Rigidbody cubeRB = cubeGo . AddComponent < Rigidbody >(); // Add randomness otherwise cubes will all show the exact same trajectory cubeRB . velocity = new Vector3 ( Random . value * . 1f ,- 1 , Random . value * . 1f ) * 5f ; cubeGo . AddComponent < DestroyOnTouch >(); return cubeGo ; } The highlighted line shows how the (publicly known) DestroyOnTouch is added as a component to each new cubeGo object, just before it is returned. Save this code and try it out: Making it pop Let's turn the chore of cleaning up cubes into a more fun activity by adding some pop. As immersive as VR is, you can heighten this even more by engaging additional senses, such as our hearing. Unity is of course capable of audio playback, so let's have it play a short sample every time we destroy a cube, such a simple \"pop\" sound. Where to get sound samples? If you're not inclined to record or synthesize your own audio, the popular website freesound.org is a great, free, source of all kinds of audible material. To save you some time for now, you can also download this .mp3 clip and use it: pop.mp3 Create a new folder in Assets called Resources , and store your audio sample there and rename it pop.mp3 , if it's not already called that. Go back to our CreateCube() function and add two lines: CubeFactory.cs public GameObject CreateCube () { GameObject cubeGo = GameObject . CreatePrimitive ( PrimitiveType . Cube ); Transform cubeTrans = cubeGo . transform ; cubeTrans . position = new Vector3 (- 1f , 0.9f , 0f ); cubeTrans . localScale = new Vector3 (. 15f ,. 15f ,. 15f ); cubeGo . GetComponent < MeshRenderer >(). material . color = Random . ColorHSV (); Rigidbody cubeRB = cubeGo . AddComponent < Rigidbody >(); // Add randomness otherwise cubes will all show the exact same trajectory cubeRB . velocity = new Vector3 ( Random . value * . 1f ,- 1 , Random . value * . 1f ) * 5f ; cubeGo . AddComponent < DestroyOnTouch >(); AudioSource cubeAS = cubeGo . AddComponent < AudioSource >(); cubeAS . clip = Resources . Load < AudioClip >( \"pop\" ); return cubeGo ; } With those, we're adding another component to the new cubes, this time an AudioSource , and loading into its clip component our .mp3 file, using Resources.Load<AudioClip>(\"pop\") . The latter call will actually search the Resources folder we created above for any audio files that are named \"pop\" before their file type extension, which is why it was important to name our clip \"pop.mp3\". Go back to our DestroyOnTouch script to modify it. We're adding a new private variable called _audioSource , and fetch it from the component the factory is now adding to new cubes using the Start() function. DestroyOnTouch.cs public class DestroyOnTouch : MonoBehaviour { private AudioSource _audioSource ; private void Start () { _audioSource = GetComponent < AudioSource >(); // Last part of the tutorial (with pop sound added) } } Wen Start()? Start() is actually not always called \"before the first frame update\" as its comment implies. If an object was created during the duration of the game, many frames could have obviously passed before this event. Furthermore, if an object is created and deactivated immediately before any frames have passed, start() is still not called. It is only ever called when just before an object \"experiences\" its first passing frame. Now let's change the remainder of DestroyOnTouch to actually play back the sound on destruction: DestroyOnTouch.cs private void OnTriggerEnter ( Collider other ) { // Destroy(gameObject); StartCoroutine ( PlayAudioThenDestroy ()); // Last part of the tutorial (with pop sound added) } private IEnumerator PlayAudioThenDestroy () { // Hide object Destroy ( GetComponent < MeshRenderer >()); // Delete collider component to prevent calling this coroutine twice Destroy ( GetComponent < Rigidbody >()); // Play pop sound _audioSource . Play (); yield return new WaitUntil (() => ! _audioSource . isPlaying ); // Actually destroy the object now Destroy ( gameObject ); } In OnTriggerEnter() , we comment out our previous line that simply destroys the object (rendering it inert) and instead add a StartCoroutine() call on the IEnumerator block we declare below. Coroutines Coroutines are a very powerful feature of Unity (and overall computing concept ), which allow delayed execution of code without tying up the whole system \u2014 effectively allowing parallel execution of multiple things. This will be explored in more detail in the following tutorial , but feel free to try to understand the PlayAudioThenDestroy() function here from its context and comments. Save the code, run the game. It pops!","title":"3 \u2022 Runtime"},{"location":"3-runtime/#runtime-automated-processes","text":"For now, our scenes have only strictly reacted to our inputs. Let's create some automated processes.","title":"Runtime: Automated Processes"},{"location":"3-runtime/#reuse-the-previous-project","text":"For this project, let's continue building on our previous one, without having to again import the libraries and creating our cubes or spheres (from the previous challenge ) that trigger collisions. Just remove (or deactivate) the cylinder GameObject from the hierarchy and delete the Controller Input (Script) component from our [CameraRig] GameObject.","title":"Reuse the previous project"},{"location":"3-runtime/#shape-of-a-cube-factory","text":"What's a better example for automation than a factory? Let's make a cube factory. Create a new, empty GameObject in the hierarchy (\"Create Empty\") and name it CubeFactory . Place it at (-1, 0, -0.25) . Now right-click on it to create child objects within it: six new cubes. Their names, positions, and scales should be as below. Editing Time Savers You can quickly enter these numbers by hitting the Tab-key after entering each one, which will advance the focus to the next field. You can also save time by omitting the zeros before periods: the editor will fill them in automatically. \"CubeRight\" Position (0, 0.9, 0) Scale (0.5, 1.8, 0.25) \"CubeLeft\" Position (0, 0.9, 0.5) Scale (0.5, 1.8, 0.25) \"CubeBack\" Position (-0.2, 0.9, 0.25) Scale (0.1, 1.8, 0.25) \"CubeSlope\" Position (0, 0.125, 0.25) Rotation (0, 0, 55) Scale (0.1, 0.6, 0.25) \"CubeFront\" Position (0.2, 1.175, 0.25) Scale (0.1, 1.25, 0.25) \"CubeInteract\" Position (0.21, 1, 0.25) Scale (0.1, 0.2, 0.2) You should end up with a hollow cuboid that has a sloped opening at its lower end \u2014 kind of like a chimney. \"CubeInteract\" should stick out just a little:","title":"Shape of a cube factory"},{"location":"3-runtime/#labeling-with-textmeshpro","text":"Another very useful \"3D Object\" we can add to the factory is Text - TextMeshPro. Create one within the CubeFactory GameObject, and give it the following parameters (it may ask you to import some resources the first time you do that \u2014 let it): Within the Rect Transform component: Position = (0.251, 1.25, 0.25) Width = 70, Height = 20 Rotation = (0, -90, 0) Scale = (0.01, 0.01, 1) Center and middle alignment icons in its TextMeshPro - Text component The following text in place of \"Sample text\": <b>Cube Factory<\\b> Touch the red part with the controller and press the trigger to create a new cube + Set its Vertex Color to anything you like You should now have a helpful label for the cube factory:","title":"Labeling with TextMeshPro"},{"location":"3-runtime/#factory-interaction","text":"For now, it's just an empty structure, doing nothing. Let's change that with some action. Create a new script for the cube we called CubeInteract , called IsCollidingChecker . It will be very similar to our old SwitchColorOnCollide script: IsCollidingChecker.cs using UnityEngine ; public class IsCollidingChecker : MonoBehaviour { public bool isColliding ; public Color [] colors ; private Material _material ; // Start is called before the first frame update void Start () { _material = GetComponent < MeshRenderer >(). material ; _material . color = colors [ 0 ]; } private void OnTriggerEnter ( Collider other ) { isColliding = true ; _material . color = colors [ 1 ]; } private void OnTriggerExit ( Collider other ) { isColliding = false ; _material . color = colors [ 0 ]; } } The main difference is that it now exposes its isColliding boolean variable to other objects. This variable is set to True whenever it is in collision, and False when not, while at the same time changing colors. Save the script and assign two colors of your liking to this component as we did before . Running the game, you can now switch the color of the CubeInteract object by hitting it with your controller, and you'll also see its Is Colliding value change accordingly:","title":"Factory interaction"},{"location":"3-runtime/#factory-scripting","text":"The factory is still not working as advertised above this fancy button. Let's change that and make some cubes. Create a new script for the CubeFactory object itself, called\u2026 CubeFactory . Script scraps This will be a larger script, so we will from now on only show parts of its code at a time \u2014 by now you should be familiar with which parts belong where. Don't worry about the order of variables and functions: as long as they are within the correct scope (brackets), it does not matter which appear first in your script. We will be using even more libraries now than before, so make sure to include all these using statements at the top.","title":"Factory scripting"},{"location":"3-runtime/#variables","text":"CubeFactory.cs using System.Diagnostics ; using UnityEngine ; using UnityEngine.InputSystem ; using Valve.VR ; Within the CubeFactory class definition, declare the following variables: CubeFactory.cs public IsCollidingChecker isCollidingChecker ; public SteamVR_Action_Boolean Trigger ; private Stopwatch stopwatch ; public int cooldown = 500 ; The first two should already be familiar from our color-changing cylinder . The second two will help us with timing: we only want to let the factory produce cubes at minimum intervals, so we create a Stopwatch to measure passing time, and a cooldown variable that lets us say how long it should rest before pumping out another cube. CubeFactory.cs void Start () { stopwatch = new Stopwatch (); stopwatch . Start (); } At the start of the game, we only initialize the stopwatch variable using the new Stopwatch() command, and start() it immediately.","title":"Variables"},{"location":"3-runtime/#cube-creation","text":"Let's now create the function that will actually generate new cubes that interact with physics, and with random colors to boot! CubeFactory.cs public GameObject CreateCube () { GameObject cubeGo = GameObject . CreatePrimitive ( PrimitiveType . Cube ); Transform cubeTrans = cubeGo . transform ; cubeTrans . position = new Vector3 (- 1f , 0.9f , 0f ); cubeTrans . localScale = new Vector3 (. 15f ,. 15f ,. 15f ); cubeGo . GetComponent < MeshRenderer >(). material . color = Random . ColorHSV (); Rigidbody cubeRB = cubeGo . AddComponent < Rigidbody >(); // Add randomness otherwise cubes will all show the exact same trajectory cubeRB . velocity = new Vector3 ( Random . value * . 1f ,- 1 , Random . value * . 1f ) * 5f ; return cubeGo ; } When called, it creates a new GameObject we call cubeGo by invoking the GameObject class' CreatePrimitive function , with PrimitiveType.Cube as the input. We take this new object's transform and store a reference to it in a new Transform object called cubeTrans , so that we can directly work on it in the next two lines, where we give it a new position and scale. Similar to how we changed the cylinder's or the CubeInteract's colors, we assign cubeGo 's default material a new color, in this case a Random combination of H ue, S aturation, and V alue (brightness). Finally, we add a Rigidbody component to it, to which we also assign a random (within bounds) velocity, to spice things up a bit in their trajectories. Since this function is declared not as void , it is expected to return something, in this case a GameObject (see the first line of the above code \u2014 the function's declaration). We obviously want to return the just created cubeGo object, which is what the last line does.","title":"Cube creation"},{"location":"3-runtime/#requesting-new-cubes","text":"We can now go to the Update() loop and a call to our cube production function: CubeFactory.cs // Update is called once per frame void Update () { if ( stopwatch . Elapsed . Milliseconds >= cooldown ) { CreateCube (); stopwatch . Restart (); } } To keep our cube production in check, we must first verify that our set stopwatch has measured enough milliseconds (more than our set cool-down period). Only then will a cube be created, and the stopwatch restarted. Save the code and see it run: the factory's output is in full swing! Trouble with UnityEngine.InputSystem? It may be that your code editor and the Unity complain about a missing UnityEngine.InputSystem . This can be easily fixed by going to the package manager and searching for InputSystem in the Unity Registry . Install it, which will also prompt Unity configure some settings and restart the editor, so make sure to save your changes before doing so.","title":"Requesting new cubes"},{"location":"3-runtime/#controlling-factory-output","text":"To avoid a Tribbles-type situation , we need to have some control over the factory's cube output. We can add some more conditions to our if statement in the Update() loop to only allow authorized personnel to run the production: CubeFactory.cs void Update () { if ( stopwatch . Elapsed . Milliseconds >= cooldown && isCollidingChecker . isColliding && Trigger . state ) { CreateCube (); stopwatch . Restart (); } } The And-operator && can be used to chain logic statements together. You can put everything within the round brackets of the if() statement in one line, but this way we preserve legibility of an otherwise unwieldy, long line. Now the if() statement will execute its block if the stopwatch has measured more than cooldown , AND a collision is detected by the CubeInspect object, AND the trigger is pulled. If any one of these conditions is not true, no cubes will be produced. This should keep the factory floor safe. Save the code, go back to the editor, and assign the CubeInteract object's Is Colliding Checker component to the cube factory script component ( like we did with the cylinder ), and set the Trigger again to InteractUI ( see cylinder ). Manual override Often it is good to include a manual override over conditions like we have above for the cube production. You can extend the if() statement with one more clause, this time an OR || operator to make it look like this: if ( stopwatch . Elapsed . Milliseconds >= cooldown && isCollidingChecker . isColliding && Trigger . state || Keyboard . current . spaceKey . wasReleasedThisFrame ) Now the only condition necessary to trigger the production of the next cube the user hitting the space button on the computer that's running Unity (while focused on the Game view), bypassing all other rules. Cubes will be now produced as fast as you can press the space bar \u2014 don't break it!","title":"Controlling factory output"},{"location":"3-runtime/#cube-removal","text":"Even with controlled production, cubes still pile up eventually. Let's clean them up.","title":"Cube removal"},{"location":"3-runtime/#destroyer-script","text":"Create a new script in the scripts folder without attaching it to any GameObject and name it DestroyOnTouch . We want it to come into action every time our controllers (i.e., their attached cubes or spheres) collide with a freshly produced cube to pop them into oblivion. DestroyOnTouch.cs using System ; using System.Collections ; using UnityEngine ; public class DestroyOnTouch : MonoBehaviour { private void OnTriggerEnter ( Collider other ) { Destroy ( gameObject ); } } The now familiar OnTriggerEnter() function will simply call the Destroy() command on gameObject itself, which refers to the GameObject this script is working within. As it is now, the code just sits in our Scripts folder and does nothing, so let's attach it to all factory-fresh cubes our CubeFactory is producing.","title":"Destroyer script"},{"location":"3-runtime/#attaching-the-destroyer","text":"To attach this script ( make sure to save it first! ) to new cubes, we simply need to modify the CreateCube() function within CubeFactory : CubeFactory.cs public GameObject CreateCube () { GameObject cubeGo = GameObject . CreatePrimitive ( PrimitiveType . Cube ); Transform cubeTrans = cubeGo . transform ; cubeTrans . position = new Vector3 (- 1f , 0.9f , 0f ); cubeTrans . localScale = new Vector3 (. 15f ,. 15f ,. 15f ); cubeGo . GetComponent < MeshRenderer >(). material . color = Random . ColorHSV (); Rigidbody cubeRB = cubeGo . AddComponent < Rigidbody >(); // Add randomness otherwise cubes will all show the exact same trajectory cubeRB . velocity = new Vector3 ( Random . value * . 1f ,- 1 , Random . value * . 1f ) * 5f ; cubeGo . AddComponent < DestroyOnTouch >(); return cubeGo ; } The highlighted line shows how the (publicly known) DestroyOnTouch is added as a component to each new cubeGo object, just before it is returned. Save this code and try it out:","title":"Attaching the destroyer"},{"location":"3-runtime/#making-it-pop","text":"Let's turn the chore of cleaning up cubes into a more fun activity by adding some pop. As immersive as VR is, you can heighten this even more by engaging additional senses, such as our hearing. Unity is of course capable of audio playback, so let's have it play a short sample every time we destroy a cube, such a simple \"pop\" sound. Where to get sound samples? If you're not inclined to record or synthesize your own audio, the popular website freesound.org is a great, free, source of all kinds of audible material. To save you some time for now, you can also download this .mp3 clip and use it: pop.mp3 Create a new folder in Assets called Resources , and store your audio sample there and rename it pop.mp3 , if it's not already called that. Go back to our CreateCube() function and add two lines: CubeFactory.cs public GameObject CreateCube () { GameObject cubeGo = GameObject . CreatePrimitive ( PrimitiveType . Cube ); Transform cubeTrans = cubeGo . transform ; cubeTrans . position = new Vector3 (- 1f , 0.9f , 0f ); cubeTrans . localScale = new Vector3 (. 15f ,. 15f ,. 15f ); cubeGo . GetComponent < MeshRenderer >(). material . color = Random . ColorHSV (); Rigidbody cubeRB = cubeGo . AddComponent < Rigidbody >(); // Add randomness otherwise cubes will all show the exact same trajectory cubeRB . velocity = new Vector3 ( Random . value * . 1f ,- 1 , Random . value * . 1f ) * 5f ; cubeGo . AddComponent < DestroyOnTouch >(); AudioSource cubeAS = cubeGo . AddComponent < AudioSource >(); cubeAS . clip = Resources . Load < AudioClip >( \"pop\" ); return cubeGo ; } With those, we're adding another component to the new cubes, this time an AudioSource , and loading into its clip component our .mp3 file, using Resources.Load<AudioClip>(\"pop\") . The latter call will actually search the Resources folder we created above for any audio files that are named \"pop\" before their file type extension, which is why it was important to name our clip \"pop.mp3\". Go back to our DestroyOnTouch script to modify it. We're adding a new private variable called _audioSource , and fetch it from the component the factory is now adding to new cubes using the Start() function. DestroyOnTouch.cs public class DestroyOnTouch : MonoBehaviour { private AudioSource _audioSource ; private void Start () { _audioSource = GetComponent < AudioSource >(); // Last part of the tutorial (with pop sound added) } } Wen Start()? Start() is actually not always called \"before the first frame update\" as its comment implies. If an object was created during the duration of the game, many frames could have obviously passed before this event. Furthermore, if an object is created and deactivated immediately before any frames have passed, start() is still not called. It is only ever called when just before an object \"experiences\" its first passing frame. Now let's change the remainder of DestroyOnTouch to actually play back the sound on destruction: DestroyOnTouch.cs private void OnTriggerEnter ( Collider other ) { // Destroy(gameObject); StartCoroutine ( PlayAudioThenDestroy ()); // Last part of the tutorial (with pop sound added) } private IEnumerator PlayAudioThenDestroy () { // Hide object Destroy ( GetComponent < MeshRenderer >()); // Delete collider component to prevent calling this coroutine twice Destroy ( GetComponent < Rigidbody >()); // Play pop sound _audioSource . Play (); yield return new WaitUntil (() => ! _audioSource . isPlaying ); // Actually destroy the object now Destroy ( gameObject ); } In OnTriggerEnter() , we comment out our previous line that simply destroys the object (rendering it inert) and instead add a StartCoroutine() call on the IEnumerator block we declare below. Coroutines Coroutines are a very powerful feature of Unity (and overall computing concept ), which allow delayed execution of code without tying up the whole system \u2014 effectively allowing parallel execution of multiple things. This will be explored in more detail in the following tutorial , but feel free to try to understand the PlayAudioThenDestroy() function here from its context and comments. Save the code, run the game. It pops!","title":"Making it pop"},{"location":"4-coroutines/","text":"Coroutines: Parallel Execution and Experiment Protocols We have mastered automated, simple events with the Cube Factory. Now let's create more complex flows and dive deeper into coroutines ! Reuse previous Unity project We can once again save some time by continuing to use the previous project. Just make sure to delete or deactivate the CubeFactory object and you should be good to go. Archiving and copying Unity projects Another way to continue work without sacrificing previously finished projects is to making a copy of a whole Unity project in your file explorer, e.g., by going to the Unity hub, right-clicking your project to \"Show in Finder/Explorer\" and copying its whole folder. You can rename the copied folder to anything you want, then go back to the Hub and clicking Open instead of new New Project , then point it to your newly copied folder. Setting the scene We create again a few new objects. Create as children of the floor plane object two new Plane 3D objects and configure them like this: \"StandingMark\" Position: (-2.333, .001, -2.333) Scale: (.1, 1, .1) \"OriginMark\" Position (0, .001, 0) Scale (.1, 1, .1) Assign StandingMark our old BlueBox material , and the RedBox material to OriginMark. Outside the floor object, at empty spaces in the hierarchy of our scene, create: A Sphere 3D object and name it \"Zeppelin\": Position (-1, 1.5, -1) Rotation (0, 90, 0) Scale (.5, .2, .2) A new Cube : Position (0, 1.5, 1) Scale (.2, .1, .2) Attach to the new Sphere (Zeppelin) and the new cube our existing IsCollidingChecker script as a component: Click Add Component and start typing in its name. Give the Is Colliding Checker components you've just attached to the Cube and Zeppelin two new colors of your choosing. They can be different to spice it up a bit! Setting objects in motion Now should have the two last objects simply hovering in the air. Let's write new scripts to get them moving. Create a script called Moving and attach it to the Zeppelin object: Moving.cs using UnityEngine ; public class Moving : MonoBehaviour { [Tooltip(\"Units per second\")] public float speed ; [Tooltip(\"Start position in 3D space\")] public Vector3 startPoint ; [Tooltip(\"End position in 3D space\")] public Vector3 endPoint ; public float interpolator = 1f ; public bool isDone => interpolator > . 999f ; void Update () { print ( isDone ); if ( isDone ) return ; interpolator += speed * Time . deltaTime ; transform . position = Vector3 . Lerp ( startPoint , endPoint , interpolator ); } } It takes speed and two Vector3 variables for its moving speed ( via interpolation ) and for start and end points of its journey. isDone? The expression isDone => interpolator > . 999f is a handy shortcut: the => operator assigns to isDone the result of evaluating interpolator > .999f , similar to how an if statement would do. You can read more about this at the C# documentation . What this effectively does is to constantly check if the interpolator is greater than .999f , and setting isDone to true if so, and false if not. interpolator being already 1 at the beginning will set isDone to true , thus aborting the execution of Update() . It will need to be set to a smaller value to get it going. This function also outputs the state of isDone to the Console at each update using the print() command: you can see it when the program is running, as it will be filling up the console with printouts quickly and keep scrolling down. Printing to console It can be a good practice to output the state of variables to the console to have a clear understanding of what is going on. Doing it as above (printing at each Update() ) is one way, but usually it is used only at specific events, like when a variable is changed. Using print() \u2014 or the Unity equivalent Debug.Log() \u2014 well is a powerful helper to understanding and debugging your code, so feel free to try it on other variables and other positions in your code by yourself! Set speed in the inspector to 0.25 , and give (-1, 1.5, -1) as the start point and (-1, 1.5, 1) as the end point for its trajectory. Now create a script called Rotating for the new cube object: Rotating.cs using UnityEngine ; public class Rotating : MonoBehaviour { [Tooltip(\"Units per second\")] public float speed ; [Tooltip(\"Axis to rotate around\")] public Vector3 axis ; public bool isRotating ; void Update () { if (! isRotating ) return ; transform . Rotate ( axis , speed * Time . deltaTime ); } } Very similar to our first rotation script , it differs only by having a public boolean called isRotating that is checked before performing the rotation \u2014 it acts basically as an on/off switch. Set the speed to 180 and the rotation axis to (1, 0, 0) in the inspector. If you run the game now, only the the cube object should be rotating, and then only if you set its isRotating parameter to true in its Rotating component in the inspector. Try it out, and play around with the parameters in the inspector to see their effects: Scripting a protocol With the two moving objects and two areas to step on have set the stage to introduce more complex flows, such as might be needed for actual experiments (or even games). Variables and assignments Create a new script for the [CameraRig] object and name it Protocol : Protocol.cs using System.Collections ; using UnityEngine ; using Valve.VR ; public class Protocol : MonoBehaviour { public SteamVR_Action_Boolean Trigger ; // Set to \\actions\\default\\in\\InteractUI in editor public Moving movingComp ; public Rotating rotatingComp ; public IsCollidingChecker zeppelinColliderChecker ; public IsCollidingChecker cubeColliderChecker ; public Transform headCamera ; public Transform standingMark ; public float positionTolerance = 0.15f ; private bool isRunning = true ; } At this point, nothing in this first part of the declaration should be unfamiliar: Protocol.cs holds a number of public variables to store a SteamVR action, four components from other objects, two transforms, a floating point number, and a boolean. Save the script as it is so far, and make sure it's attached to our [CameraRig]. Go back to the Unity editor to assign the unfilled variables in the inspector. Challenge: assign it yourself! Can you figure out yourself how to fill the fields in the inspector for the [CameraRig]'s Protocol component correctly? The names and expected types should make this easy. As for the Trigger assignment, try to remember what you did the two previous times. Continue only after you're confident you set it up correctly. Don't hesistate to ask if you're having trouble here. Interaction functions Let's give us the ability to interact with Protocol.cs within the VR world. Add these functions: Protocol.cs private void Update () { if ( Trigger . state && isRunning ) { isRunning = false ; } } private bool IsStandingOnTarget ( Vector2 targetPos ) { Vector3 pos3D = headCamera . position ; Vector2 standingPos = new Vector2 ( pos3D . x , pos3D . z ); return Vector2 . Distance ( standingPos , targetPos ) < positionTolerance ; } The Update() loop should be clear: if the trigger is pressed AND isRunning is already true, THEN turn the variable isRunning to false. IsStandingOnTarget(Vector2 targetPos) takes a given target position (a 2D vector) and measures its distance to a 2D projection of the headCamera \u2014 if it's below the positionTolerance , it return true, otherwise false. Scripted flow Let's now put these variables and functions to work. We will use the Start() call for that, but first change it from a basic private void type function, we will turn it into an IEnumerator \u2014 this way, it acts as a coroutine and we can stop and continue its execution using WaitWhile() , WaitUntil() , and WaitForSecondsRealtime() commands. Replace the current Start() function with this: Protocol.cs private IEnumerator Start () { while ( isRunning ) { // Wait until user has moved onto square on the floor Vector3 standingMarkPos = standingMark . position ; yield return new WaitWhile (() => ! IsStandingOnTarget ( new Vector2 ( standingMarkPos . x , standingMarkPos . z ))); print ( \"Stepped on the first square\" ); standingMark . gameObject . SetActive ( false ); // Hide // Wait until user has touched the zeppelin yield return new WaitUntil (() => zeppelinColliderChckr . isColliding ); print ( \"Touched the Zeppelin\" ); movingComp . interp = 0 ; // This triggers the start of Zeppelin's animation // Wait for moving animation to end yield return new WaitUntil (() => movingComp . isDone ); print ( \"Zeppelin's animation is done\" ); // Move to center of the room yield return new WaitWhile (() => ! IsStandingOnTarget ( Vector2 . zero )); print ( \"Stepped on the center square\" ); // Wait until user has touched the cube yield return new WaitUntil (() => cubeColliderChckr . isColliding ); rotatingComp . isRotating = true ; // Start rotating cube print ( \"Touched the cube\" ); // Wait one second while it rotates yield return new WaitForSecondsRealtime ( 1f ); rotatingComp . isRotating = false ; // Stop rotating cube print ( \"One second has passed\" ); // RESET everything standingMark . gameObject . SetActive ( true ); // Show movingComp . transform . position = movingComp . startPoint ; rotatingComp . transform . rotation = Quaternion . identity ; print ( \"Everything's reset!\" ); } } You should be able to read this script and understand what it's doing. The various yield return new lines halt the execution of the function (stopping the advancement to the next lines) until their Wait clauses are fulfilled, as explained in the comments for every line. Save the script, go back to Unity, and make sure the cube is not set to rotate already. Run the game, and try to advance through the different steps as you can see in the protocol! The console will print updates on the user's progress through the steps. Challenge: more triggering For now, the controller's trigger isn't actually doing much other than interrupting the flow. Can you think of a way to use it more creatively here?","title":"4 \u2022 Coroutines"},{"location":"4-coroutines/#coroutines-parallel-execution-and-experiment-protocols","text":"We have mastered automated, simple events with the Cube Factory. Now let's create more complex flows and dive deeper into coroutines !","title":"Coroutines: Parallel Execution and Experiment Protocols"},{"location":"4-coroutines/#reuse-previous-unity-project","text":"We can once again save some time by continuing to use the previous project. Just make sure to delete or deactivate the CubeFactory object and you should be good to go. Archiving and copying Unity projects Another way to continue work without sacrificing previously finished projects is to making a copy of a whole Unity project in your file explorer, e.g., by going to the Unity hub, right-clicking your project to \"Show in Finder/Explorer\" and copying its whole folder. You can rename the copied folder to anything you want, then go back to the Hub and clicking Open instead of new New Project , then point it to your newly copied folder.","title":"Reuse previous Unity project"},{"location":"4-coroutines/#setting-the-scene","text":"We create again a few new objects. Create as children of the floor plane object two new Plane 3D objects and configure them like this: \"StandingMark\" Position: (-2.333, .001, -2.333) Scale: (.1, 1, .1) \"OriginMark\" Position (0, .001, 0) Scale (.1, 1, .1) Assign StandingMark our old BlueBox material , and the RedBox material to OriginMark. Outside the floor object, at empty spaces in the hierarchy of our scene, create: A Sphere 3D object and name it \"Zeppelin\": Position (-1, 1.5, -1) Rotation (0, 90, 0) Scale (.5, .2, .2) A new Cube : Position (0, 1.5, 1) Scale (.2, .1, .2) Attach to the new Sphere (Zeppelin) and the new cube our existing IsCollidingChecker script as a component: Click Add Component and start typing in its name. Give the Is Colliding Checker components you've just attached to the Cube and Zeppelin two new colors of your choosing. They can be different to spice it up a bit!","title":"Setting the scene"},{"location":"4-coroutines/#setting-objects-in-motion","text":"Now should have the two last objects simply hovering in the air. Let's write new scripts to get them moving. Create a script called Moving and attach it to the Zeppelin object: Moving.cs using UnityEngine ; public class Moving : MonoBehaviour { [Tooltip(\"Units per second\")] public float speed ; [Tooltip(\"Start position in 3D space\")] public Vector3 startPoint ; [Tooltip(\"End position in 3D space\")] public Vector3 endPoint ; public float interpolator = 1f ; public bool isDone => interpolator > . 999f ; void Update () { print ( isDone ); if ( isDone ) return ; interpolator += speed * Time . deltaTime ; transform . position = Vector3 . Lerp ( startPoint , endPoint , interpolator ); } } It takes speed and two Vector3 variables for its moving speed ( via interpolation ) and for start and end points of its journey. isDone? The expression isDone => interpolator > . 999f is a handy shortcut: the => operator assigns to isDone the result of evaluating interpolator > .999f , similar to how an if statement would do. You can read more about this at the C# documentation . What this effectively does is to constantly check if the interpolator is greater than .999f , and setting isDone to true if so, and false if not. interpolator being already 1 at the beginning will set isDone to true , thus aborting the execution of Update() . It will need to be set to a smaller value to get it going. This function also outputs the state of isDone to the Console at each update using the print() command: you can see it when the program is running, as it will be filling up the console with printouts quickly and keep scrolling down. Printing to console It can be a good practice to output the state of variables to the console to have a clear understanding of what is going on. Doing it as above (printing at each Update() ) is one way, but usually it is used only at specific events, like when a variable is changed. Using print() \u2014 or the Unity equivalent Debug.Log() \u2014 well is a powerful helper to understanding and debugging your code, so feel free to try it on other variables and other positions in your code by yourself! Set speed in the inspector to 0.25 , and give (-1, 1.5, -1) as the start point and (-1, 1.5, 1) as the end point for its trajectory. Now create a script called Rotating for the new cube object: Rotating.cs using UnityEngine ; public class Rotating : MonoBehaviour { [Tooltip(\"Units per second\")] public float speed ; [Tooltip(\"Axis to rotate around\")] public Vector3 axis ; public bool isRotating ; void Update () { if (! isRotating ) return ; transform . Rotate ( axis , speed * Time . deltaTime ); } } Very similar to our first rotation script , it differs only by having a public boolean called isRotating that is checked before performing the rotation \u2014 it acts basically as an on/off switch. Set the speed to 180 and the rotation axis to (1, 0, 0) in the inspector. If you run the game now, only the the cube object should be rotating, and then only if you set its isRotating parameter to true in its Rotating component in the inspector. Try it out, and play around with the parameters in the inspector to see their effects:","title":"Setting objects in motion"},{"location":"4-coroutines/#scripting-a-protocol","text":"With the two moving objects and two areas to step on have set the stage to introduce more complex flows, such as might be needed for actual experiments (or even games).","title":"Scripting a protocol"},{"location":"4-coroutines/#variables-and-assignments","text":"Create a new script for the [CameraRig] object and name it Protocol : Protocol.cs using System.Collections ; using UnityEngine ; using Valve.VR ; public class Protocol : MonoBehaviour { public SteamVR_Action_Boolean Trigger ; // Set to \\actions\\default\\in\\InteractUI in editor public Moving movingComp ; public Rotating rotatingComp ; public IsCollidingChecker zeppelinColliderChecker ; public IsCollidingChecker cubeColliderChecker ; public Transform headCamera ; public Transform standingMark ; public float positionTolerance = 0.15f ; private bool isRunning = true ; } At this point, nothing in this first part of the declaration should be unfamiliar: Protocol.cs holds a number of public variables to store a SteamVR action, four components from other objects, two transforms, a floating point number, and a boolean. Save the script as it is so far, and make sure it's attached to our [CameraRig]. Go back to the Unity editor to assign the unfilled variables in the inspector. Challenge: assign it yourself! Can you figure out yourself how to fill the fields in the inspector for the [CameraRig]'s Protocol component correctly? The names and expected types should make this easy. As for the Trigger assignment, try to remember what you did the two previous times. Continue only after you're confident you set it up correctly. Don't hesistate to ask if you're having trouble here.","title":"Variables and assignments"},{"location":"4-coroutines/#interaction-functions","text":"Let's give us the ability to interact with Protocol.cs within the VR world. Add these functions: Protocol.cs private void Update () { if ( Trigger . state && isRunning ) { isRunning = false ; } } private bool IsStandingOnTarget ( Vector2 targetPos ) { Vector3 pos3D = headCamera . position ; Vector2 standingPos = new Vector2 ( pos3D . x , pos3D . z ); return Vector2 . Distance ( standingPos , targetPos ) < positionTolerance ; } The Update() loop should be clear: if the trigger is pressed AND isRunning is already true, THEN turn the variable isRunning to false. IsStandingOnTarget(Vector2 targetPos) takes a given target position (a 2D vector) and measures its distance to a 2D projection of the headCamera \u2014 if it's below the positionTolerance , it return true, otherwise false.","title":"Interaction functions"},{"location":"4-coroutines/#scripted-flow","text":"Let's now put these variables and functions to work. We will use the Start() call for that, but first change it from a basic private void type function, we will turn it into an IEnumerator \u2014 this way, it acts as a coroutine and we can stop and continue its execution using WaitWhile() , WaitUntil() , and WaitForSecondsRealtime() commands. Replace the current Start() function with this: Protocol.cs private IEnumerator Start () { while ( isRunning ) { // Wait until user has moved onto square on the floor Vector3 standingMarkPos = standingMark . position ; yield return new WaitWhile (() => ! IsStandingOnTarget ( new Vector2 ( standingMarkPos . x , standingMarkPos . z ))); print ( \"Stepped on the first square\" ); standingMark . gameObject . SetActive ( false ); // Hide // Wait until user has touched the zeppelin yield return new WaitUntil (() => zeppelinColliderChckr . isColliding ); print ( \"Touched the Zeppelin\" ); movingComp . interp = 0 ; // This triggers the start of Zeppelin's animation // Wait for moving animation to end yield return new WaitUntil (() => movingComp . isDone ); print ( \"Zeppelin's animation is done\" ); // Move to center of the room yield return new WaitWhile (() => ! IsStandingOnTarget ( Vector2 . zero )); print ( \"Stepped on the center square\" ); // Wait until user has touched the cube yield return new WaitUntil (() => cubeColliderChckr . isColliding ); rotatingComp . isRotating = true ; // Start rotating cube print ( \"Touched the cube\" ); // Wait one second while it rotates yield return new WaitForSecondsRealtime ( 1f ); rotatingComp . isRotating = false ; // Stop rotating cube print ( \"One second has passed\" ); // RESET everything standingMark . gameObject . SetActive ( true ); // Show movingComp . transform . position = movingComp . startPoint ; rotatingComp . transform . rotation = Quaternion . identity ; print ( \"Everything's reset!\" ); } } You should be able to read this script and understand what it's doing. The various yield return new lines halt the execution of the function (stopping the advancement to the next lines) until their Wait clauses are fulfilled, as explained in the comments for every line. Save the script, go back to Unity, and make sure the cube is not set to rotate already. Run the game, and try to advance through the different steps as you can see in the protocol! The console will print updates on the user's progress through the steps. Challenge: more triggering For now, the controller's trigger isn't actually doing much other than interrupting the flow. Can you think of a way to use it more creatively here?","title":"Scripted flow"},{"location":"5-io/","text":"Saving, Loading, and Writing We've seen how Unity can load an audio file and use it. Now let's see how we can make it create new files by itself, like we would like it to for recording results from experiments. New project Let's make a new Unity project for this part, as we won't be needing VR for it. Go back to the Unity Hub and do so . We're going to need the functionality of accessing a user's input, so we need to install the Input System package from the Package Manager : This may trigger a warning and a prompt to restart the Unity Editor. Allow it: We should now be all set to get going with this new project! Set the scene Let's add some objects to the scene. A signpost Create an empty GameObject and name it \"Signpost\", making sure it sits at the world origin (Position = (0,0,0) ). Right-clicking on this object, create two new cubes as its children with the following parameters: First cube: Name = \"Post\" Position = (0,.5,0) Scale = (.09,1,.09) Second cube: Name = \"Sign\" Position = (0,1.3,0) Scale = (.1,.7,1) Now add a Text - TextMeshPro object as a child to sign object in the hierarchy and give it the following parameters: Width = 40, height = 30 Position = (0.55,0,0) Rotation = (0,-90,0) Scale = (.02,.02,1) Give its text a centered alignment Prefabs Let's now turn this signpost into a Prefab \u2014 a reusable, preset object that can be easily re-created by Unity. Make a new Resources folder within our assets, and simply drag our whole Signpost GameObject from the hierarchy directly in it \u2014 a prefab with its parameters is created, giving our Signpost a blue icon! Remove the Signpost now from our hierarchy \u2014 we will use its prefab later. Reading files: texts and textures Let's get Unity to read some external files to work with in our project \u2014 in our case to spice up the appearance of our signpost. Create a text file inside the Resources folder: right-click it (or within it) in the project browser to open in in Finder/Explorer, and use any old text editor for the next steps. Name it SignpostData.txt , and give it the following contents: SignpostData.txt pos:-2,0,-1 col1:0.9,0.67,0.42 col2:1,1,1 txt:<i>NOTICE</i><br>Some text<br>To display<br>for information As you may guess, we will use this to put text on the signpost and adjust its position. To give it some texture instead of the elegant but simple white, download this image and also place it into Resources, renaming it SignpostTexture.jpg in the process. Create a Scripts folder inside Assets (there shouldn't be one there yet), make a new script there called LoadFromResources and attach it to our Floor object as a component: LoadFromResources.cs using System.Collections.Generic ; using System.Linq ; using TMPro ; using UnityEngine ; public class LoadFromResources : MonoBehaviour { // Start is called before the first frame update void Start () { // Fill this next! } } For now it doesn't do anything, so let's give is some functionality \u2014 all within its Start() method, step by step. Create variables that can hold a GameObject, a string, and a Texture2D : LoadFromResources.cs GameObject signpostPrefab = Resources . Load < GameObject >( \"Signpost\" ); string signpostData = Resources . Load < TextAsset >( \"SignpostData\" ). text ; Texture2D signpostTexture = Resources . Load < Texture2D >( \"SignpostTexture\" ); These variables are immediately assigned the output of their respective Resources.Load<Type>(\"File name\") methods, which look for files with a specific name within the Resources folder we created before, reads them, and converts them into the specified type : a GameObject fashioned after the Signpost prefab , a Texture2D from our supplied picture, and a string from our SignpostData.txt file. This last variable, the signpostData string is still somehow vague in its use, so let's change that with a parsing function. Add it right after the previous code block, still inside Start() : LoadFromResources.cs // Parse text file to get custom signpost data Dictionary < string , string > SPdataParsed = new Dictionary < string , string >(); foreach ( string line in signpostData . Split ( '\\n' )) { if ( line . Length == 0 ) continue ; // Split each line by key:value and store in dictionary string [] lineSplit = line . Split ( ':' ); SPdataParsed . Add ( lineSplit [ 0 ], lineSplit [ 1 ]); } This creates a Dictionary from our text file, taking the colon (:) as a separator for each line: the left part of a line before it (e.g., pos ) becomes a key and the right part (e.g., -2,0,-1 ) the value. Instantiating a prefab We can now use the information gotten from our signpostData.txt file to instantiate Signpost objects from the Signpost prefab and assign to them parameters that we store in our SPdataParsed dictionary: LoadFromResources.cs // Instantiate prefab as a new gameobject GameObject signpostGo = GameObject . Instantiate ( signpostPrefab ); Transform signpostTrans = signpostGo . transform ; // Set signpost world position float [] posRaw = SPdataParsed [ \"pos\" ]. Split ( ',' ). Select ( float . Parse ). ToArray (); signpostTrans . position = new Vector3 ( posRaw [ 0 ], posRaw [ 1 ], posRaw [ 2 ]); MeshRenderer [] meshRenderers = signpostGo . GetComponentsInChildren < MeshRenderer >(); // Set colour of first child in signpost object (post) float [] col1Raw = SPdataParsed [ \"col1\" ]. Split ( ',' ). Select ( float . Parse ). ToArray (); meshRenderers [ 0 ]. material . color = new Color ( col1Raw [ 0 ], col1Raw [ 1 ], col1Raw [ 2 ]); // Set colour of second child in signpost object (sign) float [] col2Raw = SPdataParsed [ \"col2\" ]. Split ( ',' ). Select ( float . Parse ). ToArray (); meshRenderers [ 1 ]. material . color = new Color ( col2Raw [ 0 ], col2Raw [ 1 ], col2Raw [ 2 ]); meshRenderers [ 0 ]. material . mainTexture = signpostTexture ; meshRenderers [ 1 ]. material . mainTexture = signpostTexture ; // Set text TextMeshPro signpostTMP = signpostGo . GetComponentInChildren < TextMeshPro >(); signpostTMP . text = SPdataParsed [ \"txt\" ]; These last lines of the Start() function should mostly speak for themselves, even the highlighted operations performed the string values from in the dictionary, though they might contain so far unseen methods like Split() and Select() \u2014 try to understand what they do (the links should help). Save the now completed LoadFromResources script, and run the game \u2014 you will see a now wooden signpost with some text on it appear at the coordinates given in the text file! It even changed the colors of the different parts of the post, making it even more realistic. You may need to move the camera bit too see it well, though: Challenge: moving the camera, too Can you apply the same method to also move the camera to a new different position? You would need to add a new line to the text file, and amend your parser to turn this instruction into action. Playlists Our LoadFromResources script has done its job \u2014 disable or remove it from the Floor object. Lets get a bit more fancy and create a playlist to sequence events; in this case we want a number of images to load and show up on the scene, one after another. Placing external resources Create a new folder ouside the Assets folder (besides it) called ExternalData . Within that new folder, place a new text file called playlists.txt with exactly the following content: playlists.txt 0,1,2,3,4,5 5,4,3,2,1,0 Info The format is important here, meaning the number of items in one line, them being separated by commas, etc. You can change the order of the numbers, add more lines in the same format, etc. \u2014 this flexibility is the whole point of creating a simple playlist file format like this! Within the ExternalData folder, create a new folder called images . Download the six images from here ( 1 , 2 , 3 , 4 , 4 , 6 ) and place them inside images in the project browser \u2014 make sure to keep their filenames intact ( img_00.jpg , etc.). Parsing and playing playlists We want these images to displayed on a Quad 3D object in the scene, so create one in the hierarchy with the following parameters: Name = DisplayQuad Position = (-1.5,1.3,0) Rotation = (0,-90,0) Scale = (1.92,1.08,1) 1.92 and 1.08 \u2014 multiply by 1,000 and you get 1920 and 1080. Looks familiar? Create a new script for the floor named LoadFromExternalFolder to put them into action: LoadFromExternalFolder.cs using System.Collections ; using System.IO ; using System.Linq ; using UnityEditor ; using UnityEngine ; public class LoadFromExternalFolder : MonoBehaviour { public static string dirpathname = \"ExternalData\" ; public static string dirpath ; public MeshRenderer displayQuadMR ; private Material displayQaudMat ; public int subj_index = 0 ; private int [] playlist ; public Texture2D LoadImageAsTexture ( string filePath ) { // Load raw data from file byte [] fileData = File . ReadAllBytes ( filePath ); Texture2D tmpTex = new Texture2D ( 1920 , 1080 , TextureFormat . RGB24 , false ); tmpTex . LoadImage ( fileData ); return tmpTex ; } } Assumptions The LoadImageAsTexture() function makes a lot of assumptions here. First, we assume that there is a valid file path stored in filePath at all, and not just gibberish. Then we further assume that the data at that location is an image that can be loaded in a texture, even with the specific dimensions 1920, 1080 and in RGB24 color format. While getting the dimensions and color format wrong wouldn't cause that much trouble other than a potentially garbled image, trying to read a file that's not there can cause the game to crash! Ususally, you would guard agains this by first checking if the file exists at all, and wouldn't you know it, there's a fuction for that: File.Exists() . To be on the safe side, you can check the result of File.Exists(filePath) in an if() statement and only proceed with loading if it's positive. Keep in mind that you still have to return some Texture2D and can't just return from you function with nothing to show for\u2026 All this to say: Playing it safe is not for lazy people, but it can sure give you a feeling of security (and save you from some crashes). Being very similar in structure to our previous script, it should be quite clear what it does. The difference so far are the variables to hold our Quad's MeshRenderer and Material, and and index to keep track of our subject. Let's use these in the Start() method: LoadFromExternalFolder.cs IEnumerator Start () { displayQaudMat = displayQuadMR . material ; dirpath = Directory . GetParent ( Application . dataPath ). ToString () + Path . DirectorySeparatorChar + dirpathname ; // image order playlist // A line represent the order to display images // There is one line per subject // Load entire image order playlist file segmened by line return playlist = File . ReadAllLines ( $\"{dirpath}/playlists.txt\" ) // Skip all lines to go to the one we want . Skip ( subj_index ) // Get one line . Take ( 1 ). First () // Split line by comma . Split ( ',' ) // Convert string to int . Select ( int . Parse ). ToArray (); for ( int ipl = 0 ; ipl < playlist . Length ; ipl ++) { int iImg = playlist [ ipl ]; displayQaudMat . mainTexture = LoadImageAsTexture ( $\"{dirpath}/images/img_{iImg:D2}.jpg\" ); yield return new WaitForSeconds ( 2f ); } Application . Quit (); #if UNITY_EDITOR EditorApplication . isPlaying = false ; #endif } Save the script, make sure its attached as a component to our floor, and assign our Quad to the appropriate field. It will now cycle through the images it loads in the given sequence read from the playlists file, which we can specify in the components inspector with the Subj_index field (starting with 0), and then quit the game! Preprocessor Directives \u2014 Unity Macros Macros #if #endif Writing to files Let's now turn the tables on our file system and write something to it, instead of only reading! Deactivate the display Quad, deactivate the LoadFromExternalFolder component from our Floor, and create yet another new script for it. Call it SaveToExternalFolder : SaveToExternalFolder.cs using System ; using System.Collections ; using System.IO ; using UnityEngine ; using UnityEngine.InputSystem ; public class SaveToExternalFolder : MonoBehaviour { public static string dirpathname = \"ExternalData/subjData/\" ; public static string dirpath ; public int subj_index = 0 ; private StreamWriter expeDataWriter ; public static long GetTimestamp () { return DateTimeOffset . Now . ToUnixTimeMilliseconds (); } private void OnApplicationQuit () { expeDataWriter . Flush (); expeDataWriter . Close (); } } For now it only contains the now-familiar variables to hold the names of file paths and subject index, as well as a StreamWriter and a simple getter method that returns a time stamp using the DateTimeOffset structure. There is now also a method called OnApplicationQuit() \u2014 similar to how Start() is automatically executed by Unity when you press the Play button, this one runs just as stop the game, be it by pressing the play button again or quitting the whole Unity editor (or the final, built binary executable ). This is important if you're writing to external files: the Flush() and Close() commands make sure that all potentially unwritten contents of the StreamWriter are flushed out to the file, and that the file is then properly closed \u2014 this is just basic file system hygiene, perhaps not too dissimilar from the one you practice yourself. Let's put these things together in a Start() IEnumerator: SaveToExternalFolder.cs IEnumerator Start () { dirpath = Directory . GetParent ( Application . dataPath ). ToString () + Path . DirectorySeparatorChar + dirpathname ; Directory . CreateDirectory ( $\"{dirpath}\" ); expeDataWriter = new StreamWriter ( $\"{dirpath}/subj_{subj_index}.txt\" ); while ( true ) { yield return new WaitUntil (() => Keyboard . current . anyKey . wasReleasedThisFrame ); for ( int ik = 0 ; ik < Keyboard . KeyCount ; ik ++) { string keyName = Keyboard . current . allKeys [ ik ]. ToString (); bool keyState = Keyboard . current . allKeys [ ik ]. wasReleasedThisFrame ; if (! keyState ) continue ; string message = $\"{GetTimestamp()}: user released \\\"{keyName}\\\"\" ; expeDataWriter . WriteLine ( message ); print ( message ); } } } First, it creates a new directory at the constructed dirpath if it doesn't exist yet, then instantiates a new StreamWriter with a new file, which itself is constructed from the dirpath and the subj_index using String Interpolation (the $ sign). Try to understand how the final file name and directory are being assembled! Then an endless loop ( while (true) ) is being run that keeps waiting for the user to hit (or rather release after hitting) keys on the keyboard using WaitUntil and the new Unity Input System in the shape of Keyboard.current.anyKey.wasReleasedThisFrame . It then looks at which keys were being pressed and puts their names in a string. As we can't easily access the exact key that was pressed, we just write down all current keys ( Keyboard.current.allKeys ). We then check if one of these current keys was just released in the last frame \u2014 if not, we exit this loop with the continue jump statement . If the key was just released, we formulate a message including its name and the current time stamp (from our GetTimeStamp() method), and hand it over to the expeDataWriter to write a line in our external file using WriteLine() . Additionally, we print this message to the console. And that's it for external files! Now let's finally try out interacting with gaze data in Unity in the next tutorial. Challenge: elapsed time Instead of writing the time stamp (the absolute, real-world time), how about writing down the time that has elapsed between two key releases? To calculate that, you would need to keep track of the time the last key was pressed and subtract that from the current time. Give it a try if you want! Challenge: slide show Can you combine the functionality of our last script with the previous one to have the user manually advance the images shown in on the signpost?","title":"5 \u2022\u00a0Saving, Loading, Writing"},{"location":"5-io/#saving-loading-and-writing","text":"We've seen how Unity can load an audio file and use it. Now let's see how we can make it create new files by itself, like we would like it to for recording results from experiments.","title":"Saving, Loading, and Writing"},{"location":"5-io/#new-project","text":"Let's make a new Unity project for this part, as we won't be needing VR for it. Go back to the Unity Hub and do so . We're going to need the functionality of accessing a user's input, so we need to install the Input System package from the Package Manager : This may trigger a warning and a prompt to restart the Unity Editor. Allow it: We should now be all set to get going with this new project!","title":"New project"},{"location":"5-io/#set-the-scene","text":"Let's add some objects to the scene.","title":"Set the scene"},{"location":"5-io/#a-signpost","text":"Create an empty GameObject and name it \"Signpost\", making sure it sits at the world origin (Position = (0,0,0) ). Right-clicking on this object, create two new cubes as its children with the following parameters: First cube: Name = \"Post\" Position = (0,.5,0) Scale = (.09,1,.09) Second cube: Name = \"Sign\" Position = (0,1.3,0) Scale = (.1,.7,1) Now add a Text - TextMeshPro object as a child to sign object in the hierarchy and give it the following parameters: Width = 40, height = 30 Position = (0.55,0,0) Rotation = (0,-90,0) Scale = (.02,.02,1) Give its text a centered alignment","title":"A signpost"},{"location":"5-io/#prefabs","text":"Let's now turn this signpost into a Prefab \u2014 a reusable, preset object that can be easily re-created by Unity. Make a new Resources folder within our assets, and simply drag our whole Signpost GameObject from the hierarchy directly in it \u2014 a prefab with its parameters is created, giving our Signpost a blue icon! Remove the Signpost now from our hierarchy \u2014 we will use its prefab later.","title":"Prefabs"},{"location":"5-io/#reading-files-texts-and-textures","text":"Let's get Unity to read some external files to work with in our project \u2014 in our case to spice up the appearance of our signpost. Create a text file inside the Resources folder: right-click it (or within it) in the project browser to open in in Finder/Explorer, and use any old text editor for the next steps. Name it SignpostData.txt , and give it the following contents: SignpostData.txt pos:-2,0,-1 col1:0.9,0.67,0.42 col2:1,1,1 txt:<i>NOTICE</i><br>Some text<br>To display<br>for information As you may guess, we will use this to put text on the signpost and adjust its position. To give it some texture instead of the elegant but simple white, download this image and also place it into Resources, renaming it SignpostTexture.jpg in the process. Create a Scripts folder inside Assets (there shouldn't be one there yet), make a new script there called LoadFromResources and attach it to our Floor object as a component: LoadFromResources.cs using System.Collections.Generic ; using System.Linq ; using TMPro ; using UnityEngine ; public class LoadFromResources : MonoBehaviour { // Start is called before the first frame update void Start () { // Fill this next! } } For now it doesn't do anything, so let's give is some functionality \u2014 all within its Start() method, step by step. Create variables that can hold a GameObject, a string, and a Texture2D : LoadFromResources.cs GameObject signpostPrefab = Resources . Load < GameObject >( \"Signpost\" ); string signpostData = Resources . Load < TextAsset >( \"SignpostData\" ). text ; Texture2D signpostTexture = Resources . Load < Texture2D >( \"SignpostTexture\" ); These variables are immediately assigned the output of their respective Resources.Load<Type>(\"File name\") methods, which look for files with a specific name within the Resources folder we created before, reads them, and converts them into the specified type : a GameObject fashioned after the Signpost prefab , a Texture2D from our supplied picture, and a string from our SignpostData.txt file. This last variable, the signpostData string is still somehow vague in its use, so let's change that with a parsing function. Add it right after the previous code block, still inside Start() : LoadFromResources.cs // Parse text file to get custom signpost data Dictionary < string , string > SPdataParsed = new Dictionary < string , string >(); foreach ( string line in signpostData . Split ( '\\n' )) { if ( line . Length == 0 ) continue ; // Split each line by key:value and store in dictionary string [] lineSplit = line . Split ( ':' ); SPdataParsed . Add ( lineSplit [ 0 ], lineSplit [ 1 ]); } This creates a Dictionary from our text file, taking the colon (:) as a separator for each line: the left part of a line before it (e.g., pos ) becomes a key and the right part (e.g., -2,0,-1 ) the value.","title":"Reading files: texts and textures"},{"location":"5-io/#instantiating-a-prefab","text":"We can now use the information gotten from our signpostData.txt file to instantiate Signpost objects from the Signpost prefab and assign to them parameters that we store in our SPdataParsed dictionary: LoadFromResources.cs // Instantiate prefab as a new gameobject GameObject signpostGo = GameObject . Instantiate ( signpostPrefab ); Transform signpostTrans = signpostGo . transform ; // Set signpost world position float [] posRaw = SPdataParsed [ \"pos\" ]. Split ( ',' ). Select ( float . Parse ). ToArray (); signpostTrans . position = new Vector3 ( posRaw [ 0 ], posRaw [ 1 ], posRaw [ 2 ]); MeshRenderer [] meshRenderers = signpostGo . GetComponentsInChildren < MeshRenderer >(); // Set colour of first child in signpost object (post) float [] col1Raw = SPdataParsed [ \"col1\" ]. Split ( ',' ). Select ( float . Parse ). ToArray (); meshRenderers [ 0 ]. material . color = new Color ( col1Raw [ 0 ], col1Raw [ 1 ], col1Raw [ 2 ]); // Set colour of second child in signpost object (sign) float [] col2Raw = SPdataParsed [ \"col2\" ]. Split ( ',' ). Select ( float . Parse ). ToArray (); meshRenderers [ 1 ]. material . color = new Color ( col2Raw [ 0 ], col2Raw [ 1 ], col2Raw [ 2 ]); meshRenderers [ 0 ]. material . mainTexture = signpostTexture ; meshRenderers [ 1 ]. material . mainTexture = signpostTexture ; // Set text TextMeshPro signpostTMP = signpostGo . GetComponentInChildren < TextMeshPro >(); signpostTMP . text = SPdataParsed [ \"txt\" ]; These last lines of the Start() function should mostly speak for themselves, even the highlighted operations performed the string values from in the dictionary, though they might contain so far unseen methods like Split() and Select() \u2014 try to understand what they do (the links should help). Save the now completed LoadFromResources script, and run the game \u2014 you will see a now wooden signpost with some text on it appear at the coordinates given in the text file! It even changed the colors of the different parts of the post, making it even more realistic. You may need to move the camera bit too see it well, though: Challenge: moving the camera, too Can you apply the same method to also move the camera to a new different position? You would need to add a new line to the text file, and amend your parser to turn this instruction into action.","title":"Instantiating a prefab"},{"location":"5-io/#playlists","text":"Our LoadFromResources script has done its job \u2014 disable or remove it from the Floor object. Lets get a bit more fancy and create a playlist to sequence events; in this case we want a number of images to load and show up on the scene, one after another.","title":"Playlists"},{"location":"5-io/#placing-external-resources","text":"Create a new folder ouside the Assets folder (besides it) called ExternalData . Within that new folder, place a new text file called playlists.txt with exactly the following content: playlists.txt 0,1,2,3,4,5 5,4,3,2,1,0 Info The format is important here, meaning the number of items in one line, them being separated by commas, etc. You can change the order of the numbers, add more lines in the same format, etc. \u2014 this flexibility is the whole point of creating a simple playlist file format like this! Within the ExternalData folder, create a new folder called images . Download the six images from here ( 1 , 2 , 3 , 4 , 4 , 6 ) and place them inside images in the project browser \u2014 make sure to keep their filenames intact ( img_00.jpg , etc.).","title":"Placing external resources"},{"location":"5-io/#parsing-and-playing-playlists","text":"We want these images to displayed on a Quad 3D object in the scene, so create one in the hierarchy with the following parameters: Name = DisplayQuad Position = (-1.5,1.3,0) Rotation = (0,-90,0) Scale = (1.92,1.08,1) 1.92 and 1.08 \u2014 multiply by 1,000 and you get 1920 and 1080. Looks familiar? Create a new script for the floor named LoadFromExternalFolder to put them into action: LoadFromExternalFolder.cs using System.Collections ; using System.IO ; using System.Linq ; using UnityEditor ; using UnityEngine ; public class LoadFromExternalFolder : MonoBehaviour { public static string dirpathname = \"ExternalData\" ; public static string dirpath ; public MeshRenderer displayQuadMR ; private Material displayQaudMat ; public int subj_index = 0 ; private int [] playlist ; public Texture2D LoadImageAsTexture ( string filePath ) { // Load raw data from file byte [] fileData = File . ReadAllBytes ( filePath ); Texture2D tmpTex = new Texture2D ( 1920 , 1080 , TextureFormat . RGB24 , false ); tmpTex . LoadImage ( fileData ); return tmpTex ; } } Assumptions The LoadImageAsTexture() function makes a lot of assumptions here. First, we assume that there is a valid file path stored in filePath at all, and not just gibberish. Then we further assume that the data at that location is an image that can be loaded in a texture, even with the specific dimensions 1920, 1080 and in RGB24 color format. While getting the dimensions and color format wrong wouldn't cause that much trouble other than a potentially garbled image, trying to read a file that's not there can cause the game to crash! Ususally, you would guard agains this by first checking if the file exists at all, and wouldn't you know it, there's a fuction for that: File.Exists() . To be on the safe side, you can check the result of File.Exists(filePath) in an if() statement and only proceed with loading if it's positive. Keep in mind that you still have to return some Texture2D and can't just return from you function with nothing to show for\u2026 All this to say: Playing it safe is not for lazy people, but it can sure give you a feeling of security (and save you from some crashes). Being very similar in structure to our previous script, it should be quite clear what it does. The difference so far are the variables to hold our Quad's MeshRenderer and Material, and and index to keep track of our subject. Let's use these in the Start() method: LoadFromExternalFolder.cs IEnumerator Start () { displayQaudMat = displayQuadMR . material ; dirpath = Directory . GetParent ( Application . dataPath ). ToString () + Path . DirectorySeparatorChar + dirpathname ; // image order playlist // A line represent the order to display images // There is one line per subject // Load entire image order playlist file segmened by line return playlist = File . ReadAllLines ( $\"{dirpath}/playlists.txt\" ) // Skip all lines to go to the one we want . Skip ( subj_index ) // Get one line . Take ( 1 ). First () // Split line by comma . Split ( ',' ) // Convert string to int . Select ( int . Parse ). ToArray (); for ( int ipl = 0 ; ipl < playlist . Length ; ipl ++) { int iImg = playlist [ ipl ]; displayQaudMat . mainTexture = LoadImageAsTexture ( $\"{dirpath}/images/img_{iImg:D2}.jpg\" ); yield return new WaitForSeconds ( 2f ); } Application . Quit (); #if UNITY_EDITOR EditorApplication . isPlaying = false ; #endif } Save the script, make sure its attached as a component to our floor, and assign our Quad to the appropriate field. It will now cycle through the images it loads in the given sequence read from the playlists file, which we can specify in the components inspector with the Subj_index field (starting with 0), and then quit the game! Preprocessor Directives \u2014 Unity Macros Macros #if #endif","title":"Parsing and playing playlists"},{"location":"5-io/#writing-to-files","text":"Let's now turn the tables on our file system and write something to it, instead of only reading! Deactivate the display Quad, deactivate the LoadFromExternalFolder component from our Floor, and create yet another new script for it. Call it SaveToExternalFolder : SaveToExternalFolder.cs using System ; using System.Collections ; using System.IO ; using UnityEngine ; using UnityEngine.InputSystem ; public class SaveToExternalFolder : MonoBehaviour { public static string dirpathname = \"ExternalData/subjData/\" ; public static string dirpath ; public int subj_index = 0 ; private StreamWriter expeDataWriter ; public static long GetTimestamp () { return DateTimeOffset . Now . ToUnixTimeMilliseconds (); } private void OnApplicationQuit () { expeDataWriter . Flush (); expeDataWriter . Close (); } } For now it only contains the now-familiar variables to hold the names of file paths and subject index, as well as a StreamWriter and a simple getter method that returns a time stamp using the DateTimeOffset structure. There is now also a method called OnApplicationQuit() \u2014 similar to how Start() is automatically executed by Unity when you press the Play button, this one runs just as stop the game, be it by pressing the play button again or quitting the whole Unity editor (or the final, built binary executable ). This is important if you're writing to external files: the Flush() and Close() commands make sure that all potentially unwritten contents of the StreamWriter are flushed out to the file, and that the file is then properly closed \u2014 this is just basic file system hygiene, perhaps not too dissimilar from the one you practice yourself. Let's put these things together in a Start() IEnumerator: SaveToExternalFolder.cs IEnumerator Start () { dirpath = Directory . GetParent ( Application . dataPath ). ToString () + Path . DirectorySeparatorChar + dirpathname ; Directory . CreateDirectory ( $\"{dirpath}\" ); expeDataWriter = new StreamWriter ( $\"{dirpath}/subj_{subj_index}.txt\" ); while ( true ) { yield return new WaitUntil (() => Keyboard . current . anyKey . wasReleasedThisFrame ); for ( int ik = 0 ; ik < Keyboard . KeyCount ; ik ++) { string keyName = Keyboard . current . allKeys [ ik ]. ToString (); bool keyState = Keyboard . current . allKeys [ ik ]. wasReleasedThisFrame ; if (! keyState ) continue ; string message = $\"{GetTimestamp()}: user released \\\"{keyName}\\\"\" ; expeDataWriter . WriteLine ( message ); print ( message ); } } } First, it creates a new directory at the constructed dirpath if it doesn't exist yet, then instantiates a new StreamWriter with a new file, which itself is constructed from the dirpath and the subj_index using String Interpolation (the $ sign). Try to understand how the final file name and directory are being assembled! Then an endless loop ( while (true) ) is being run that keeps waiting for the user to hit (or rather release after hitting) keys on the keyboard using WaitUntil and the new Unity Input System in the shape of Keyboard.current.anyKey.wasReleasedThisFrame . It then looks at which keys were being pressed and puts their names in a string. As we can't easily access the exact key that was pressed, we just write down all current keys ( Keyboard.current.allKeys ). We then check if one of these current keys was just released in the last frame \u2014 if not, we exit this loop with the continue jump statement . If the key was just released, we formulate a message including its name and the current time stamp (from our GetTimeStamp() method), and hand it over to the expeDataWriter to write a line in our external file using WriteLine() . Additionally, we print this message to the console. And that's it for external files! Now let's finally try out interacting with gaze data in Unity in the next tutorial. Challenge: elapsed time Instead of writing the time stamp (the absolute, real-world time), how about writing down the time that has elapsed between two key releases? To calculate that, you would need to keep track of the time the last key was pressed and subtract that from the current time. Give it a try if you want! Challenge: slide show Can you combine the functionality of our last script with the previous one to have the user manually advance the images shown in on the signpost?","title":"Writing to files"},{"location":"6-gaze/","text":"Using Gaze Data It's time for the final piece of the puzzle: using actual gaze data provided by the built-in eye tracker in our HTC Vive Pro Eye devices. Look out! Complex code, complex concepts In this part, we will provide some code that would a bit too complex to fully explain in the time we have. You can of course try to understand it (and we encourage that!), but feel free to take this as an exercise in reusing existing solutions to problems that you don't have to reinvent yourself. Reuse or Rebuild Again, we can reuse our previous VR Unity projects to save time, practice the necessary steps to set one up from scratch. Make sure that SteamVR and the SRAnipal packages are installed and imported into our project, and that we have a [CameraRig] object instead of the default MainCamera in our hierarchy. Have a Scrips folder in our assets, as well as a Resource folder, which contains the pop.mp3 audio sample we've used before. Have a Plane 3D object as a floor in the scene \u2014 name it Floor . Setting up gaze tracking There are a number of procedures necessary to do in code in order to have an eye tracker running and being useful in Unity, and they can be quite lengthy. Download this script file and place it in your Scripts folder in the Project browser: EyeTrackingCtrlr.cs . Using the ViveSR.anipal.Eye library, it interfaces directly with the eye tracker inside the Vive Pro Eye \u2014 within it's Start() enumerator it waits for the hardware to be ready before continuing. EyeTrackingCtrlr.cs defines a new class called GazePoint within itself, which holds information about where a user is looking with each eye (as well as a combination of both), and which (if any) objects the gaze rays are colliding with. This \"camera data\" is updated each frame by calling SRanipal_Eye.GetGazeRay() functions that interface with the eye tracker, while \"Eye data\" is gathered when the function EyeCallback() is called directly by the eye tracker via a callback . General-purpose script Overall, this script is very generalized and can be used for all sorts of projects with minimal alterations. The only specialized functionality in this script is that it specifically checks if a gaze collision happens with objects that have CollidableCube in their name, to which it then sends a OnTriggerEnter message : if ( gazePoint . LeftCollide != null && gazePoint . LeftCollide . name == \"CollidableCube\" ) gazePoint . LeftCollide . SendMessage ( \"OnTriggerEnter\" , new Collider (), SendMessageOptions . DontRequireReceiver ); If you want to create your own projects building on this script, this would be the only part you'd really need to change. Attach this script to the Floor object as a component, so that it runs within our scene. Visualizing gaze We shall now create cubes that will change their color once we gaze at them. This will be done in a similar manner to our Cube Factory : new cubes will be created and outfitted with the necessary functionality. Animating cubes We don't want cubes to just disappear for now as we did with the cube factory, but let them instead change colors (suddenly, then gradually). Create a new script in the Scripts folder named AnimateOnCollide.cs : AnimateOnCollide.cs using System.Collections ; using UnityEngine ; public class AnimateOnCollide : MonoBehaviour { public bool isColliding ; public Color [] colors ; private Material _material ; private float _animationDuration = . 25f ; private IEnumerator Animate () { float animationTime = _animationDuration ; // Interpolate between color one and two while ( animationTime >= 0 ) { yield return null ; // Wait one frame animationTime -= Time . deltaTime ; _material . color = Color . Lerp ( colors [ 1 ], colors [ 0 ], 1 - animationTime / _animationDuration ); } } } It is again similar to our previous \u2026OnCollide scripts in structure. The IEnumerator Animate() will count down from the duration given in _animationDuration while steadily \"lerping\" , or interpolating between the first two colors in its colors array, and assign them to the objects's material. Give this script now its Start() function to set an initial color, and an OnTriggerEnter() function which will (re)start the Animate() coroutine when a collision is detected: AnimateOnCollide.cs void Start () { _material = GetComponent < MeshRenderer >(). material ; _material . color = colors [ 0 ]; } // Now sent by EyeTrackingCtrlr.cs! public void OnTriggerEnter ( Collider other ) { StopAllCoroutines (); StartCoroutine ( Animate ()); } Creating cubes for gaze visualization Our floor will now be a kind of cube factory. Create a new script for the floor plane object called ProtocolVisualiseGaze , which for now contains only its library calls, a single private variable (the EyeTrackingCtrlr), and a method for creating new, interactive cubes: ProtocolVisualiseGaze.cs using System ; using System.Collections ; using UnityEngine ; using ViveSR.anipal.Eye ; using Random = UnityEngine . Random ; public class ProtocolVisualiseGaze : MonoBehaviour { private EyeTrackingCtrlr eyeTrackingCtrlr ; private static void CreateInteractiveCube ( Vector3 position , Quaternion rotation , Color col1 ) { GameObject cubeGo = GameObject . CreatePrimitive ( PrimitiveType . Cube ); cubeGo . name = \"CollidableCube\" ; Transform cubeTrans = cubeGo . transform ; cubeTrans . position = position ; cubeTrans . rotation = rotation ; cubeTrans . localScale *= . 15f ; AnimateOnCollide cubeCollChk = cubeGo . AddComponent < AnimateOnCollide >(); cubeCollChk . colors = new [] { col1 , new Color ( 1f - col1 . r , 1f - col1 . g , 1f - col1 . b ) }; } } CreateInteractiveCube() can create cubes with a given position , rotation , and color , and outfits them with our AnimateOnCollide component. It gives them the name \"CollidableCube\", and assigns their AnimateOnCollide component two colors: one given to the CreateInteractiveCube() function via the col1 parameter, and its opposite via the new Color (1f-col1.r, 1f-col1.g, 1f-col1.b) command. Now add a Start() IEnumerator to this script to execute cube generation: ProtocolVisualiseGaze.cs IEnumerator Start () { eyeTrackingCtrlr = EyeTrackingCtrlr . instance ; yield return new WaitUntil (() => eyeTrackingCtrlr . isReady ); // Calibrate eye tracker once at the start - comment out after first time bool calibrationSuccess = false ; while (! calibrationSuccess ) { int calibReturnCode = SRanipal_Eye_API . LaunchEyeCalibration ( IntPtr . Zero ); print ( $\"calibReturnCode: {calibReturnCode} == {(int) ViveSR.Error.WORK}\" ); calibrationSuccess = calibReturnCode == ( int ) ViveSR . Error . WORK ; } // Create floating cubes in a square formation around the room's origin Vector2 [] moveVec = new [] { new Vector2 ( 0 ,- 1 ), new Vector2 ( 1 , 0 ), new Vector2 ( 0 , 1 ), new Vector2 (- 1 , 0 ), }; Vector3 startPos = new Vector3 ( 1.8f , 1.6f , 1.8f ); for ( int iBorder = 0 ; iBorder < 4 ; iBorder ++) { float tmpVal = startPos . x ; startPos . x = - startPos . z ; startPos . z = tmpVal ; for ( int iCube = 0 ; iCube < 4 ; iCube ++) { Vector3 position = startPos ; position . x += moveVec [ iBorder ]. x * ( 3.6f / 4f * iCube ); position . z += moveVec [ iBorder ]. y * ( 3.6f / 4f * iCube ); CreateInteractiveCube ( position , Random . rotation , Random . ColorHSV ()); yield return new WaitForSeconds (. 1f ); } } } While this function looks long, it's rather simple in what it does: It instantiates a new EyeTrackingCtrlr , thereby getting our code above to run It pauses until the eye tracker is ready Attempts to calibrate the eye tracker , and finally Creates four interactive cubes around the center of the room with random colors and orientations. Challenge: Add a toggle for calibration The block of code responsible for calibrating the eye tracker does not need to run every time, and will be rather annoying if you have to go through it each time you try the script. Currently, there is a line that says \"comment out after first time\" \u2014 you can surely do that, and uncomment again whenever you do want run the calibration routine again, but this, too, can get old, fast. As a challenge you can try create a new bool calibrate variable that's visible in the inspector, and have it determine whether the calibration block is executed! Save the code and try it out. See if you can activate cubes by just looking at them: Challenge: Fix blinking cubes As you can see, the cubes just blink briefly as we graze them with our gaze. Do you think you can change AnimateOnCollide in such a way that the cubes stay in their activated color until we look away from them? If looks could destroy Instead of animating our cubes by looking at them, let's destroy them as we did the surplus output from our Cube Factory . Create a new script called DestroyOnCollide in our scripts folder: DestroyOnCollide.cs using System.Collections ; using UnityEngine ; public class DestroyOnCollide : MonoBehaviour { private AudioSource _audioSource ; private void Start () { _audioSource = gameObject . AddComponent < AudioSource >(); _audioSource . playOnAwake = false ; _audioSource . clip = Resources . Load < AudioClip >( \"pop\" ); } private void OnTriggerEnter ( Collider other ) { StartCoroutine ( PlayAudioThenDestroy ()); } private IEnumerator PlayAudioThenDestroy () { print ( $\"Destoyed {name}\" ); // Hide object Destroy ( GetComponent < MeshRenderer >()); // Delete collider component to prevent calling this coroutine twice Destroy ( GetComponent < Rigidbody >()); // Play pop sound _audioSource . Play (); yield return new WaitUntil (() => ! _audioSource . isPlaying ); // Actually destroy the object now Destroy ( gameObject ); } } Its structure should be nothing new by now. Go back to our ProtocolVisualiseGaze script and change its CreateInteractiveCube() function to look like this: ProtocolVisualiseGaze.cs private static void CreateInteractiveCube ( Vector3 position , Quaternion rotation , Color col1 ) { GameObject cubeGo = GameObject . CreatePrimitive ( PrimitiveType . Cube ); cubeGo . name = \"CollidableCube\" ; Transform cubeTrans = cubeGo . transform ; cubeTrans . position = position ; cubeTrans . rotation = rotation ; cubeTrans . localScale *= . 15f ; cubeGo . AddComponent < DestroyOnCollide >(); cubeGo . GetComponent < MeshRenderer >(). material . color = col1 ; } Save the code, run the game, and get popping! Sampling gaze While it can be fun to pop some cubes from time to time, we're here to learn about getting some science from all this, so let's actually collect data and save it in external files. Gaze sampler script Download a modified version of our EyeTrackingCtrlr here, now called EyeTrackingSmplr.cs and put in the Scripts folder. It is very similar to our previous EyeTrackingCtrlr.cs script, differing only in its inclusion of a StreamWriter which it will use to record data to a file, and its EyeCallback() method, which will now use that StreamWriter to add new entries to our recording every time the eye tracker updates its data. You can see how it does that in its EyeCallback() method, but here is its part that determines the format of its output: EyeTrackingSmplr.cs instance . writer . WriteLine ( $\"{gazePoint.data.timestamp},{instance.UnityTimeStamp},\" + $\"{instance.cameraPosition.x},{instance.cameraPosition.y},{instance.cameraPosition.z},\" + $\"{instance.cameraQuaternion.x},{instance.cameraQuaternion.y},\" + $\"{instance.cameraQuaternion.z},{instance.cameraQuaternion.w},\" + $\"{meanBasePoint.x},{meanBasePoint.y},{meanBasePoint.z},\" + $\"{meanGazeDirection.x},{meanGazeDirection.y},{meanGazeDirection.z},\" + $\"{leftBasePoint.x},{leftBasePoint.y},{leftBasePoint.z},\" + $\"{leftGazeDirection.x},{leftGazeDirection.y},{leftGazeDirection.z},\" + $\"{rightBasePoint.x},{rightBasePoint.y},{rightBasePoint.z},\" + $\"{rightGazeDirection.x},{rightGazeDirection.y},{rightGazeDirection.z},\" + $\"{letPupilDiam},{rightPupilDiam},\" + $\"{valC},{valL},{valR}\" , false ); Looking a bit ungainly, you should still be able to decipher it. The + signs at the end of each line except the last are needed to keep it all one string, and the $ signs at the beginnings of blocks within \"\" quotation marks lets Unity convert all the variables (e.g., rightPupilDiam) to plain text for the writer (and us). Replace the EyeTracking Ctrlr component in our floor object with the new EyeTrackingSmplr.cs script (or keep both the old one but deactivate it). New protocol script To conduct a repeatable experiment we need a new protocol. Download a new version of ProtocolVisualiseGaze.cs , now called CubeSequenceSampling.cs . You can of course update the ProtocolVisualiseGaze script manually with the changes you see in ProtocolVisualiseGaze. There are now a few more variables, which we will need to tell the script where to write data to, and a container which will hold our generated cubes to keep the organization a bit more tidy. CubeSequenceSampling.cs public class CubeSequenceSampling : MonoBehaviour { private EyeTrackingSmplr eyeTrackingSmplr ; public static string dirpathname = \"subjData/\" ; public static string dirpath ; private Transform CubeContainerTrans ; } Within its Start() function, it now creates a new file path to store our data: CubeSequenceSampling.cs dirpath = Directory . GetParent ( Application . dataPath ). ToString () + Path . DirectorySeparatorChar + dirpathname ; Directory . CreateDirectory ( $\"{dirpath}\" ); eyeTrackingSmplr = EyeTrackingSmplr . instance ; yield return new WaitUntil (() => eyeTrackingSmplr . isReady ); When creating our randomly-colored cubes, we now store them inside the (so far empty) CubeContainerTrans GameObject, and promptly deactivate them. CubeSequenceSampling.cs CubeContainerTrans = new GameObject ( \"CubeContainer\" ). transform ; Vector3 startPos = new Vector3 ( 1.8f , 1.6f , 1.8f ); for ( int iBorder = 0 ; iBorder < 4 ; iBorder ++) { float tmpVal = startPos . x ; startPos . x = - startPos . z ; startPos . z = tmpVal ; for ( int iCube = 0 ; iCube < 4 ; iCube ++) { Vector3 position = startPos ; position . x += moveVec [ iBorder ]. x * ( 3.6f / 4f * iCube ); position . z += moveVec [ iBorder ]. y * ( 3.6f / 4f * iCube ); GameObject cube = CreateInteractiveCube ( position , Random . rotation , Random . ColorHSV ()); cube . SetActive ( false ); } } This storing happens in the modified CreateInteractiveCube() method, where the new cube gets a parent assigned \u2014 our CubeContainerTrans: CubeSequenceSampling.cs private GameObject CreateInteractiveCube ( Vector3 position , Quaternion rotation , Color col1 ) { GameObject cubeGo = GameObject . CreatePrimitive ( PrimitiveType . Cube ); cubeGo . name = \"CollidableCube\" ; Transform cubeTrans = cubeGo . transform ; cubeTrans . position = position ; cubeTrans . rotation = rotation ; cubeTrans . localScale *= . 15f ; // Assign this cube as a child of \"CubeContainer\" GameObject cubeTrans . SetParent ( CubeContainerTrans ); cubeGo . AddComponent < DestroyOnCollide >(); cubeGo . GetComponent < MeshRenderer >(). material . color = col1 ; return cubeGo ; } Popping cubes for science Coming back to its Start() function, its last part now randomly reactivates cubes. This makes them susceptible to being destroyed by a gaze from the participant, which the code is waiting for before reacting the next one in line until they are all gone. A variable itrial keeps track of which cube we're currently at, by being incremented ( itrial++ ) in each iteration of the while() loop. CubeSequenceSampling.cs int itrial = 0 ; while ( CubeContainerTrans . childCount > 0 ) { int iCube = ( int )( Random . value * CubeContainerTrans . childCount ); GameObject cubeGO = CubeContainerTrans . GetChild ( iCube ). gameObject ; // Show cube cubeGO . SetActive ( true ); eyeTrackingSmplr . writer = new StreamWriter ( $\"{dirpath}/Cube_{itrial++}.csv\" ); eyeTrackingSmplr . isSampling = true ; // Wait for cube to be destroyed yield return new WaitUntil (() => cubeGO == null ); eyeTrackingSmplr . isSampling = false ; eyeTrackingSmplr . writer . Close (); } It also creates a new writer within its eyeTrackingSmplr , so that it can pass a new file name for each cube. The eyeTrackingSmplr is turned on by setting its isSampling value to true until the cube is popped, which is also when we close the existing writer. With each iteration we thus create one new recording and decrease the count of remaining cubes by one, until the while ( CubeContainerTrans . childCount > 0 ) loop exits. And that's it! Replace the old ProtocolVisualiseGaze component of our floor object with this new script (or just deactivate it before adding the new one), and give it a go. You can see the resulting recordings in the automatically created SubjData folder, which you can find in the project's main folder, outside Assets. That wasn't so hard, was it ;-) Challenges Here are some suggestions to practice what you've hopefully learned here: Challenge: Analyze the data! Have a look at the generated .csv files. What can you see from them? Also, we currently only store the raw values and nothing else. Can you let our game create a header for the files that tells software like R or Numbers what each column means? Challenge: Signal the start and end of a session? Can you think of a way to signal to the participant in VR that all cubes are popped and their quest is over? What about a count down at the beginning, so that the data for the first popped cube is more consistent, i.e. waiting with the recording of the first trial until some interaction or visible event occuring? Challenge: New folders for each participant? Right now, all files are written when you restart the game. Can you think of way to e.g., enter a participant's number, so that a new folder is created for each run? More formally, we would ask you to apply all you've learned from these tutorials up to now to a final challenge on the next page , which may also challenge your creativity!","title":"6 \u2022\u00a0Using Gaze Data"},{"location":"6-gaze/#using-gaze-data","text":"It's time for the final piece of the puzzle: using actual gaze data provided by the built-in eye tracker in our HTC Vive Pro Eye devices. Look out! Complex code, complex concepts In this part, we will provide some code that would a bit too complex to fully explain in the time we have. You can of course try to understand it (and we encourage that!), but feel free to take this as an exercise in reusing existing solutions to problems that you don't have to reinvent yourself.","title":"Using Gaze Data"},{"location":"6-gaze/#reuse-or-rebuild","text":"Again, we can reuse our previous VR Unity projects to save time, practice the necessary steps to set one up from scratch. Make sure that SteamVR and the SRAnipal packages are installed and imported into our project, and that we have a [CameraRig] object instead of the default MainCamera in our hierarchy. Have a Scrips folder in our assets, as well as a Resource folder, which contains the pop.mp3 audio sample we've used before. Have a Plane 3D object as a floor in the scene \u2014 name it Floor .","title":"Reuse or Rebuild"},{"location":"6-gaze/#setting-up-gaze-tracking","text":"There are a number of procedures necessary to do in code in order to have an eye tracker running and being useful in Unity, and they can be quite lengthy. Download this script file and place it in your Scripts folder in the Project browser: EyeTrackingCtrlr.cs . Using the ViveSR.anipal.Eye library, it interfaces directly with the eye tracker inside the Vive Pro Eye \u2014 within it's Start() enumerator it waits for the hardware to be ready before continuing. EyeTrackingCtrlr.cs defines a new class called GazePoint within itself, which holds information about where a user is looking with each eye (as well as a combination of both), and which (if any) objects the gaze rays are colliding with. This \"camera data\" is updated each frame by calling SRanipal_Eye.GetGazeRay() functions that interface with the eye tracker, while \"Eye data\" is gathered when the function EyeCallback() is called directly by the eye tracker via a callback . General-purpose script Overall, this script is very generalized and can be used for all sorts of projects with minimal alterations. The only specialized functionality in this script is that it specifically checks if a gaze collision happens with objects that have CollidableCube in their name, to which it then sends a OnTriggerEnter message : if ( gazePoint . LeftCollide != null && gazePoint . LeftCollide . name == \"CollidableCube\" ) gazePoint . LeftCollide . SendMessage ( \"OnTriggerEnter\" , new Collider (), SendMessageOptions . DontRequireReceiver ); If you want to create your own projects building on this script, this would be the only part you'd really need to change. Attach this script to the Floor object as a component, so that it runs within our scene.","title":"Setting up gaze tracking"},{"location":"6-gaze/#visualizing-gaze","text":"We shall now create cubes that will change their color once we gaze at them. This will be done in a similar manner to our Cube Factory : new cubes will be created and outfitted with the necessary functionality.","title":"Visualizing gaze"},{"location":"6-gaze/#animating-cubes","text":"We don't want cubes to just disappear for now as we did with the cube factory, but let them instead change colors (suddenly, then gradually). Create a new script in the Scripts folder named AnimateOnCollide.cs : AnimateOnCollide.cs using System.Collections ; using UnityEngine ; public class AnimateOnCollide : MonoBehaviour { public bool isColliding ; public Color [] colors ; private Material _material ; private float _animationDuration = . 25f ; private IEnumerator Animate () { float animationTime = _animationDuration ; // Interpolate between color one and two while ( animationTime >= 0 ) { yield return null ; // Wait one frame animationTime -= Time . deltaTime ; _material . color = Color . Lerp ( colors [ 1 ], colors [ 0 ], 1 - animationTime / _animationDuration ); } } } It is again similar to our previous \u2026OnCollide scripts in structure. The IEnumerator Animate() will count down from the duration given in _animationDuration while steadily \"lerping\" , or interpolating between the first two colors in its colors array, and assign them to the objects's material. Give this script now its Start() function to set an initial color, and an OnTriggerEnter() function which will (re)start the Animate() coroutine when a collision is detected: AnimateOnCollide.cs void Start () { _material = GetComponent < MeshRenderer >(). material ; _material . color = colors [ 0 ]; } // Now sent by EyeTrackingCtrlr.cs! public void OnTriggerEnter ( Collider other ) { StopAllCoroutines (); StartCoroutine ( Animate ()); }","title":"Animating cubes"},{"location":"6-gaze/#creating-cubes-for-gaze-visualization","text":"Our floor will now be a kind of cube factory. Create a new script for the floor plane object called ProtocolVisualiseGaze , which for now contains only its library calls, a single private variable (the EyeTrackingCtrlr), and a method for creating new, interactive cubes: ProtocolVisualiseGaze.cs using System ; using System.Collections ; using UnityEngine ; using ViveSR.anipal.Eye ; using Random = UnityEngine . Random ; public class ProtocolVisualiseGaze : MonoBehaviour { private EyeTrackingCtrlr eyeTrackingCtrlr ; private static void CreateInteractiveCube ( Vector3 position , Quaternion rotation , Color col1 ) { GameObject cubeGo = GameObject . CreatePrimitive ( PrimitiveType . Cube ); cubeGo . name = \"CollidableCube\" ; Transform cubeTrans = cubeGo . transform ; cubeTrans . position = position ; cubeTrans . rotation = rotation ; cubeTrans . localScale *= . 15f ; AnimateOnCollide cubeCollChk = cubeGo . AddComponent < AnimateOnCollide >(); cubeCollChk . colors = new [] { col1 , new Color ( 1f - col1 . r , 1f - col1 . g , 1f - col1 . b ) }; } } CreateInteractiveCube() can create cubes with a given position , rotation , and color , and outfits them with our AnimateOnCollide component. It gives them the name \"CollidableCube\", and assigns their AnimateOnCollide component two colors: one given to the CreateInteractiveCube() function via the col1 parameter, and its opposite via the new Color (1f-col1.r, 1f-col1.g, 1f-col1.b) command. Now add a Start() IEnumerator to this script to execute cube generation: ProtocolVisualiseGaze.cs IEnumerator Start () { eyeTrackingCtrlr = EyeTrackingCtrlr . instance ; yield return new WaitUntil (() => eyeTrackingCtrlr . isReady ); // Calibrate eye tracker once at the start - comment out after first time bool calibrationSuccess = false ; while (! calibrationSuccess ) { int calibReturnCode = SRanipal_Eye_API . LaunchEyeCalibration ( IntPtr . Zero ); print ( $\"calibReturnCode: {calibReturnCode} == {(int) ViveSR.Error.WORK}\" ); calibrationSuccess = calibReturnCode == ( int ) ViveSR . Error . WORK ; } // Create floating cubes in a square formation around the room's origin Vector2 [] moveVec = new [] { new Vector2 ( 0 ,- 1 ), new Vector2 ( 1 , 0 ), new Vector2 ( 0 , 1 ), new Vector2 (- 1 , 0 ), }; Vector3 startPos = new Vector3 ( 1.8f , 1.6f , 1.8f ); for ( int iBorder = 0 ; iBorder < 4 ; iBorder ++) { float tmpVal = startPos . x ; startPos . x = - startPos . z ; startPos . z = tmpVal ; for ( int iCube = 0 ; iCube < 4 ; iCube ++) { Vector3 position = startPos ; position . x += moveVec [ iBorder ]. x * ( 3.6f / 4f * iCube ); position . z += moveVec [ iBorder ]. y * ( 3.6f / 4f * iCube ); CreateInteractiveCube ( position , Random . rotation , Random . ColorHSV ()); yield return new WaitForSeconds (. 1f ); } } } While this function looks long, it's rather simple in what it does: It instantiates a new EyeTrackingCtrlr , thereby getting our code above to run It pauses until the eye tracker is ready Attempts to calibrate the eye tracker , and finally Creates four interactive cubes around the center of the room with random colors and orientations. Challenge: Add a toggle for calibration The block of code responsible for calibrating the eye tracker does not need to run every time, and will be rather annoying if you have to go through it each time you try the script. Currently, there is a line that says \"comment out after first time\" \u2014 you can surely do that, and uncomment again whenever you do want run the calibration routine again, but this, too, can get old, fast. As a challenge you can try create a new bool calibrate variable that's visible in the inspector, and have it determine whether the calibration block is executed! Save the code and try it out. See if you can activate cubes by just looking at them: Challenge: Fix blinking cubes As you can see, the cubes just blink briefly as we graze them with our gaze. Do you think you can change AnimateOnCollide in such a way that the cubes stay in their activated color until we look away from them?","title":"Creating cubes for gaze visualization"},{"location":"6-gaze/#if-looks-could-destroy","text":"Instead of animating our cubes by looking at them, let's destroy them as we did the surplus output from our Cube Factory . Create a new script called DestroyOnCollide in our scripts folder: DestroyOnCollide.cs using System.Collections ; using UnityEngine ; public class DestroyOnCollide : MonoBehaviour { private AudioSource _audioSource ; private void Start () { _audioSource = gameObject . AddComponent < AudioSource >(); _audioSource . playOnAwake = false ; _audioSource . clip = Resources . Load < AudioClip >( \"pop\" ); } private void OnTriggerEnter ( Collider other ) { StartCoroutine ( PlayAudioThenDestroy ()); } private IEnumerator PlayAudioThenDestroy () { print ( $\"Destoyed {name}\" ); // Hide object Destroy ( GetComponent < MeshRenderer >()); // Delete collider component to prevent calling this coroutine twice Destroy ( GetComponent < Rigidbody >()); // Play pop sound _audioSource . Play (); yield return new WaitUntil (() => ! _audioSource . isPlaying ); // Actually destroy the object now Destroy ( gameObject ); } } Its structure should be nothing new by now. Go back to our ProtocolVisualiseGaze script and change its CreateInteractiveCube() function to look like this: ProtocolVisualiseGaze.cs private static void CreateInteractiveCube ( Vector3 position , Quaternion rotation , Color col1 ) { GameObject cubeGo = GameObject . CreatePrimitive ( PrimitiveType . Cube ); cubeGo . name = \"CollidableCube\" ; Transform cubeTrans = cubeGo . transform ; cubeTrans . position = position ; cubeTrans . rotation = rotation ; cubeTrans . localScale *= . 15f ; cubeGo . AddComponent < DestroyOnCollide >(); cubeGo . GetComponent < MeshRenderer >(). material . color = col1 ; } Save the code, run the game, and get popping!","title":"If looks could destroy"},{"location":"6-gaze/#sampling-gaze","text":"While it can be fun to pop some cubes from time to time, we're here to learn about getting some science from all this, so let's actually collect data and save it in external files.","title":"Sampling gaze"},{"location":"6-gaze/#gaze-sampler-script","text":"Download a modified version of our EyeTrackingCtrlr here, now called EyeTrackingSmplr.cs and put in the Scripts folder. It is very similar to our previous EyeTrackingCtrlr.cs script, differing only in its inclusion of a StreamWriter which it will use to record data to a file, and its EyeCallback() method, which will now use that StreamWriter to add new entries to our recording every time the eye tracker updates its data. You can see how it does that in its EyeCallback() method, but here is its part that determines the format of its output: EyeTrackingSmplr.cs instance . writer . WriteLine ( $\"{gazePoint.data.timestamp},{instance.UnityTimeStamp},\" + $\"{instance.cameraPosition.x},{instance.cameraPosition.y},{instance.cameraPosition.z},\" + $\"{instance.cameraQuaternion.x},{instance.cameraQuaternion.y},\" + $\"{instance.cameraQuaternion.z},{instance.cameraQuaternion.w},\" + $\"{meanBasePoint.x},{meanBasePoint.y},{meanBasePoint.z},\" + $\"{meanGazeDirection.x},{meanGazeDirection.y},{meanGazeDirection.z},\" + $\"{leftBasePoint.x},{leftBasePoint.y},{leftBasePoint.z},\" + $\"{leftGazeDirection.x},{leftGazeDirection.y},{leftGazeDirection.z},\" + $\"{rightBasePoint.x},{rightBasePoint.y},{rightBasePoint.z},\" + $\"{rightGazeDirection.x},{rightGazeDirection.y},{rightGazeDirection.z},\" + $\"{letPupilDiam},{rightPupilDiam},\" + $\"{valC},{valL},{valR}\" , false ); Looking a bit ungainly, you should still be able to decipher it. The + signs at the end of each line except the last are needed to keep it all one string, and the $ signs at the beginnings of blocks within \"\" quotation marks lets Unity convert all the variables (e.g., rightPupilDiam) to plain text for the writer (and us). Replace the EyeTracking Ctrlr component in our floor object with the new EyeTrackingSmplr.cs script (or keep both the old one but deactivate it).","title":"Gaze sampler script"},{"location":"6-gaze/#new-protocol-script","text":"To conduct a repeatable experiment we need a new protocol. Download a new version of ProtocolVisualiseGaze.cs , now called CubeSequenceSampling.cs . You can of course update the ProtocolVisualiseGaze script manually with the changes you see in ProtocolVisualiseGaze. There are now a few more variables, which we will need to tell the script where to write data to, and a container which will hold our generated cubes to keep the organization a bit more tidy. CubeSequenceSampling.cs public class CubeSequenceSampling : MonoBehaviour { private EyeTrackingSmplr eyeTrackingSmplr ; public static string dirpathname = \"subjData/\" ; public static string dirpath ; private Transform CubeContainerTrans ; } Within its Start() function, it now creates a new file path to store our data: CubeSequenceSampling.cs dirpath = Directory . GetParent ( Application . dataPath ). ToString () + Path . DirectorySeparatorChar + dirpathname ; Directory . CreateDirectory ( $\"{dirpath}\" ); eyeTrackingSmplr = EyeTrackingSmplr . instance ; yield return new WaitUntil (() => eyeTrackingSmplr . isReady ); When creating our randomly-colored cubes, we now store them inside the (so far empty) CubeContainerTrans GameObject, and promptly deactivate them. CubeSequenceSampling.cs CubeContainerTrans = new GameObject ( \"CubeContainer\" ). transform ; Vector3 startPos = new Vector3 ( 1.8f , 1.6f , 1.8f ); for ( int iBorder = 0 ; iBorder < 4 ; iBorder ++) { float tmpVal = startPos . x ; startPos . x = - startPos . z ; startPos . z = tmpVal ; for ( int iCube = 0 ; iCube < 4 ; iCube ++) { Vector3 position = startPos ; position . x += moveVec [ iBorder ]. x * ( 3.6f / 4f * iCube ); position . z += moveVec [ iBorder ]. y * ( 3.6f / 4f * iCube ); GameObject cube = CreateInteractiveCube ( position , Random . rotation , Random . ColorHSV ()); cube . SetActive ( false ); } } This storing happens in the modified CreateInteractiveCube() method, where the new cube gets a parent assigned \u2014 our CubeContainerTrans: CubeSequenceSampling.cs private GameObject CreateInteractiveCube ( Vector3 position , Quaternion rotation , Color col1 ) { GameObject cubeGo = GameObject . CreatePrimitive ( PrimitiveType . Cube ); cubeGo . name = \"CollidableCube\" ; Transform cubeTrans = cubeGo . transform ; cubeTrans . position = position ; cubeTrans . rotation = rotation ; cubeTrans . localScale *= . 15f ; // Assign this cube as a child of \"CubeContainer\" GameObject cubeTrans . SetParent ( CubeContainerTrans ); cubeGo . AddComponent < DestroyOnCollide >(); cubeGo . GetComponent < MeshRenderer >(). material . color = col1 ; return cubeGo ; }","title":"New protocol script"},{"location":"6-gaze/#popping-cubes-for-science","text":"Coming back to its Start() function, its last part now randomly reactivates cubes. This makes them susceptible to being destroyed by a gaze from the participant, which the code is waiting for before reacting the next one in line until they are all gone. A variable itrial keeps track of which cube we're currently at, by being incremented ( itrial++ ) in each iteration of the while() loop. CubeSequenceSampling.cs int itrial = 0 ; while ( CubeContainerTrans . childCount > 0 ) { int iCube = ( int )( Random . value * CubeContainerTrans . childCount ); GameObject cubeGO = CubeContainerTrans . GetChild ( iCube ). gameObject ; // Show cube cubeGO . SetActive ( true ); eyeTrackingSmplr . writer = new StreamWriter ( $\"{dirpath}/Cube_{itrial++}.csv\" ); eyeTrackingSmplr . isSampling = true ; // Wait for cube to be destroyed yield return new WaitUntil (() => cubeGO == null ); eyeTrackingSmplr . isSampling = false ; eyeTrackingSmplr . writer . Close (); } It also creates a new writer within its eyeTrackingSmplr , so that it can pass a new file name for each cube. The eyeTrackingSmplr is turned on by setting its isSampling value to true until the cube is popped, which is also when we close the existing writer. With each iteration we thus create one new recording and decrease the count of remaining cubes by one, until the while ( CubeContainerTrans . childCount > 0 ) loop exits. And that's it! Replace the old ProtocolVisualiseGaze component of our floor object with this new script (or just deactivate it before adding the new one), and give it a go. You can see the resulting recordings in the automatically created SubjData folder, which you can find in the project's main folder, outside Assets. That wasn't so hard, was it ;-)","title":"Popping cubes for science"},{"location":"6-gaze/#challenges","text":"Here are some suggestions to practice what you've hopefully learned here: Challenge: Analyze the data! Have a look at the generated .csv files. What can you see from them? Also, we currently only store the raw values and nothing else. Can you let our game create a header for the files that tells software like R or Numbers what each column means? Challenge: Signal the start and end of a session? Can you think of a way to signal to the participant in VR that all cubes are popped and their quest is over? What about a count down at the beginning, so that the data for the first popped cube is more consistent, i.e. waiting with the recording of the first trial until some interaction or visible event occuring? Challenge: New folders for each participant? Right now, all files are written when you restart the game. Can you think of way to e.g., enter a participant's number, so that a new folder is created for each run? More formally, we would ask you to apply all you've learned from these tutorials up to now to a final challenge on the next page , which may also challenge your creativity!","title":"Challenges"},{"location":"7-challenge/","text":"Final Challenge: Gaze Saber A quick review of what you should have learned so far: Creating a Unity project and navigating its interface Making, manipulating, and animating objects using C# scripting Giving your application interactivity and controlling its execution flow Reading and using external resources and recording things that happened during the game to external files Utilizing eye tracking in your application for interaction and data gathering","title":"7 \u2022\u00a0Final Challenge"},{"location":"7-challenge/#final-challenge-gaze-saber","text":"A quick review of what you should have learned so far: Creating a Unity project and navigating its interface Making, manipulating, and animating objects using C# scripting Giving your application interactivity and controlling its execution flow Reading and using external resources and recording things that happened during the game to external files Utilizing eye tracking in your application for interaction and data gathering","title":"Final Challenge: Gaze Saber"},{"location":"page-0/","text":"Installation and Setup Installing Unity","title":"Installation and Setup"},{"location":"page-0/#installation-and-setup","text":"","title":"Installation and Setup"},{"location":"page-0/#installing-unity","text":"","title":"Installing Unity"}]}